<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ ‡ç­¾ç®¡ç†åå°</title>
  <style>
    :root {
      --bg: #F3E9DD;
      --surface: #FAF4EC;
      --text: #5C4033;
      --muted: #D9CBBE;
      --accent: #8B5E3C;
      --accent-2: #6D4C3D;
      --pill-bg: #EADFD2;
    }

    html, body { background: var(--bg); color: var(--text); font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, Noto Sans, "Noto Sans CJK SC", sans-serif; }
    body { margin: 24px; max-width: 980px; margin-left: auto; margin-right: auto; }
    h1 { font-size: 24px; margin: 0 0 16px; }
    .card { background: var(--surface); border: 1px solid var(--muted); border-radius: 12px; padding: 16px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: 10px; border: 1px solid var(--muted); background: var(--surface); cursor: pointer; }
    .btn.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    .btn.danger { background: #B5534E; color: #fff; border-color: #B5534E; }
    .btn.small { padding: 6px 10px; border-radius: 8px; }
    .muted { color: #9A8274; font-size: 13px; }
    input[type="text"], textarea { padding: 8px 10px; border: 1px solid var(--muted); border-radius: 8px; background: #fff; color: var(--text); }
    input[type="text"] { height: 34px; }
    .input-sm { height: 30px; padding: 6px 8px; }
    .space { height: 16px; }
    .grid { display: grid; gap: 12px; }
    .category { border: 1px dashed var(--muted); border-radius: 10px; padding: 12px; background: #fff; }
    .category-head { display: flex; align-items: center; gap: 10px; justify-content: space-between; }
    .tags-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    .tags-table th, .tags-table td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
    .tags-table th { font-weight: 600; color: #7b6558; background: #f9f6f2; }
    .right { text-align: right; }
    .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .token-box { display: flex; align-items: center; gap: 8px; }
    .status { margin-top: 10px; font-weight: 600; color: var(--accent-2); }
    .hidden { display: none; }
    .drag-handle { cursor: grab; user-select: none; color: #9A8274; display: inline-flex; align-items: center; justify-content: center; width: 24px; }
    .drag-handle::before { content: "â‰¡"; font-size: 18px; line-height: 1; }
    .dragging { opacity: 0.6; }
    .drag-over { outline: 2px dashed var(--accent); outline-offset: 2px; }
    .col-handle { width: 36px; }
    .big-check { width: 18px; height: 18px; accent-color: var(--accent); }
    .tags-table th, .tags-table td { vertical-align: middle; }
    .tags-table.fixed { width: 100%; table-layout: fixed; }
    .tags-table.fixed th.col-handle, .tags-table.fixed td.col-handle { width: 36px; }
    .tags-table.fixed th.col-name, .tags-table.fixed td.col-name { width: 80%; }
    .tags-table.fixed th.col-op, .tags-table.fixed td.col-op { width: 20%; text-align: center; }
    .add-tag-btn { width: 32px; height: 32px; border-radius: 50%; border: none; cursor: pointer; color: #fff; background: var(--accent); display: inline-flex; align-items: center; justify-content: center; font-size: 18px; line-height: 1; margin-top: 8px; }
    .add-tag-btn:hover { background: var(--accent-2); }
    .collapse-toggle { 
      display: inline-flex; 
      align-items: center; 
      justify-content: center; 
      width: 20px; 
      height: 20px; 
      border: none; 
      background: transparent; 
      color: #9A8274; 
      cursor: pointer; 
      font-size: 14px; 
      line-height: 1; 
      transition: color 0.15s ease, transform 0.15s ease;
      padding: 0;
      margin-right: 4px;
    }
    .collapse-toggle:hover { color: var(--accent); }
    .collapse-toggle.collapsed { transform: rotate(-90deg); }
    
    /* é¢„è§ˆåŒºåŸŸæ ·å¼ */
    #tagsPreview { 
      padding: 16px; 
      background: #fff; 
      border-radius: 8px; 
      min-height: 400px;
      overflow-y: visible; 
    }
    #tagsPreview.collapsed { 
      max-height: 200px; 
      overflow-y: auto;
    }
    .preview-category { 
      margin-bottom: 20px; 
      padding: 12px; 
      background: var(--surface); 
      border: 1px solid var(--muted); 
      border-radius: 8px;
      position: relative;
    }
    .preview-category-header { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      margin-bottom: 10px; 
      font-weight: 600;
      color: var(--text);
    }
    .preview-category-header .category-name { flex: 1; }
    .preview-category-header .quick-add { 
      opacity: 0; 
      transition: opacity 0.2s; 
    }
    .preview-category:hover .quick-add { opacity: 1; }
    .preview-pill-group { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 10px; 
    }
    .preview-pill {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 36px;
      padding: 0 14px;
      border-radius: 999px;
      border: 1px solid var(--muted);
      background: var(--pill-bg);
      color: var(--text);
      cursor: move;
      transition: all 0.15s ease;
      user-select: none;
    }
    .preview-pill:hover { border-color: var(--accent); box-shadow: 0 2px 6px rgba(139,94,60,0.15); }
    .preview-pill.dragging { opacity: 0.5; }
    .preview-pill.drag-over-pill { outline: 2px solid var(--accent); outline-offset: 2px; }
    .preview-pill-lg { 
      height: 42px; 
      padding: 0 18px; 
      font-size: 16px; 
      font-weight: 600; 
      background: #DFCDBB;
    }
    .preview-category.drag-over-cat { 
      outline: 2px dashed var(--accent); 
      outline-offset: 4px; 
    }
    .quick-add-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: none;
      background: var(--accent);
      color: #fff;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      line-height: 1;
      padding: 0;
    }
    .quick-add-btn:hover { background: var(--accent-2); }
  </style>
</head>
<body>
  <div class="header">
    <h1>æ ‡ç­¾ç®¡ç†åå°</h1>
    <div class="token-box">
      <input type="password" id="adminToken" placeholder="ç®¡ç†å‘˜ Token" class="input-sm" style="width:220px;">
      <button class="btn small" id="toggleToken">æ˜¾ç¤º</button>
      <button class="btn primary small" id="saveToken">ä¿å­˜Token</button>
      <button class="btn small" id="clearToken">æ¸…é™¤</button>
    </div>
  </div>

  <div class="card" id="guardCard">
    <div class="row">
      <div>
        <div style="font-weight:600; margin-bottom:6px;">éœ€è¦ç®¡ç†å‘˜ Token</div>
        <div class="muted">å°†é€šè¿‡ Authorization: Bearer å¤´å‘é€ï¼Œä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ï¼Œä¸ä¼šä¸Šä¼ ã€‚</div>
      </div>
      <div style="flex:1"></div>
      <button class="btn primary" id="enterAdmin">è¿›å…¥ç®¡ç†</button>
    </div>
  </div>

  <div class="space"></div>

  <div id="editor" class="hidden">
    <div class="card">
      <div class="row" style="justify-content: space-between; margin-bottom: 12px;">
        <div>
          <div style="font-weight:700;">Tags é¢„è§ˆ</div>
          <div class="muted">å®æ—¶æŸ¥çœ‹æ ‡ç­¾æ•ˆæœï¼Œæ‹–æ‹½æ’åºï¼Œå³é”®åˆ é™¤ï¼ŒHover å¤§ç±»å¯å¿«é€Ÿæ·»åŠ æ ‡ç­¾ã€‚</div>
        </div>
        <div class="row">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #876;">
            <span>åˆ†åŒº:</span>
            <select id="previewPartition" style="padding: 4px 8px; border: 1px solid var(--muted); border-radius: 6px; background: #fff;">
              <option value="">å…¬å…±</option>
              <option value="feibianxian">éè¾¹é™</option>
              <option value="bianxian">è¾¹é™</option>
              <option value="shenyuan">æ·±æ¸Š</option>
            </select>
          </label>
          <button class="btn small" id="addPreviewCategory">+ æ–°å¢å¤§ç±»</button>
          <button class="btn primary small" id="savePreview">ä¿å­˜é¢„è§ˆæ›´æ”¹</button>
          <button class="btn small" id="togglePreviewSize">å±•å¼€/æ”¶èµ·</button>
        </div>
      </div>
      <div id="tagsPreview" style="border: 1px solid var(--muted);">
        <!-- åŠ¨æ€æ¸²æŸ“ tags é¢„è§ˆ -->
      </div>
    </div>

    <div class="space"></div>
    <div class="space"></div>

    <div class="card">
      <div class="row" style="justify-content: space-between;">
        <div>
          <div style="font-weight:700;">æ¿å—ç®¡ç†</div>
          <div class="muted">æ‹–æ‹½å·¦ä¾§æŠŠæ‰‹å¯è°ƒæ•´æ¿å—é¡ºåºï¼›æ¯ä¸ªæ¿å—å†…å¯å¢åˆ æ¡ç›®ã€‚</div>
        </div>
        <div class="row">
          <button class="btn" id="reloadConfig">é‡æ–°åŠ è½½</button>
          <button class="btn primary" id="saveConfig">ä¿å­˜æ›´æ”¹</button>
        </div>
      </div>
      <div class="space"></div>
      <div id="sectionsHost" class="grid"></div>
      <div class="space"></div>
      <div class="row" style="justify-content: space-between; align-items: center;">
        <button class="btn" id="addSection">+ æ–°å¢æ¿å—</button>
        <div class="row">
          <button class="btn" id="reloadConfig2">é‡æ–°åŠ è½½</button>
          <button class="btn primary" id="saveConfig2">ä¿å­˜æ›´æ”¹</button>
        </div>
      </div>
      <div id="status" class="status"></div>
    </div>
  </div>

  <script>
    const state = {
      config: null
    };

    function getToken() {
      return localStorage.getItem('admin_token') || (document.getElementById('adminToken').value || '').trim();
    }

    function setStatus(text, isError) {
      const el = document.getElementById('status');
      el.textContent = text || '';
      el.style.color = isError ? '#B5534E' : 'var(--accent-2)';
    }

    function h(tag, attrs = {}, children = []) {
      const el = document.createElement(tag);
      Object.entries(attrs).forEach(([k, v]) => {
        if (k === 'class') el.className = v;
        else if (k === 'text') el.textContent = v;
        else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.slice(2), v);
        else if (k === 'checked' || k === 'disabled' || k === 'selected') el[k] = v; // DOM å±æ€§è€Œé attribute
        else el.setAttribute(k, v);
      });
      children.forEach(c => el.appendChild(typeof c === 'string' ? document.createTextNode(c) : c));
      return el;
    }

    async function loadConfig() {
      setStatus('');
      const res = await fetch('/api/config');
      const data = await res.json();
      if (!data.success) throw new Error(data.message || 'åŠ è½½å¤±è´¥');
      state.config = data.config || {};
      normalizeSections();
      renderSections();
    }

  function normalizeSections() {
    // ç”Ÿæˆç»Ÿä¸€çš„ sections é¡ºåºï¼Œé»˜è®¤ partition åœ¨ç¬¬ä¸€ä¸ª
    if (!Array.isArray(state.config.sections)) {
      state.config.sections = ['partition'];
    }
    if (!state.config.sections.includes('partition')) {
      state.config.sections.unshift('partition');
    }
  }

    function renderSections() {
      const host = document.getElementById('sectionsHost');
      host.innerHTML = '';
      const order = state.config.sections || [];
      order.forEach((key, idx) => {
        if (key === 'partition') host.appendChild(renderPartitionSection(idx));
        else if (key.startsWith('custom:')) {
          const title = key.slice(7);
          host.appendChild(renderCustomSectionByTitle(title, idx));
        }
      });
      // åŒæ­¥æ›´æ–°é¢„è§ˆ
      renderTagsPreview();
    }

    function renderPartitionSection(sectionIndex) {
      const wrap = h('div', { class: 'category', draggable: 'true' });
      const body = h('div', { id: 'partitions' });
      const toggleBtn = h('button', { class: 'collapse-toggle', title: 'æ”¶èµ·/å±•å¼€' }, ['â–¼']);
      toggleBtn.onclick = () => { 
        const hidden = body.classList.toggle('hidden'); 
        toggleBtn.classList.toggle('collapsed', hidden);
      };
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [
          toggleBtn,
          h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', onmousedown: () => { dragState.allowed = true; } }),
          h('div', { text: 'åˆ†åŒºä¸“å± Tags', style: 'font-weight:600;' })
        ]),
        h('div', {}, [ h('span', { class: 'muted', text: 'åŒ…å« å…¬å…±/éè¾¹é™/è¾¹é™/æ·±æ¸Š' }) ])
      ]);
      // å…ˆæŒ‚è½½ï¼Œå†æ¸²æŸ“å†…éƒ¨å†…å®¹ï¼Œé¿å…æ‰¾ä¸åˆ°èŠ‚ç‚¹
      wrap.appendChild(head);
      wrap.appendChild(body);
      renderPartitions(body);
      // æ‹–æ‹½æ’åºæ”¯æŒ
      wrap.addEventListener('dragstart', (e) => { if (!dragState.allowed) { e.preventDefault(); return; } dragState.mode='section'; dragState.srcIndex = sectionIndex; wrap.classList.add('dragging'); setTimeout(()=>{dragState.allowed=false;},0); });
      wrap.addEventListener('dragend', ()=> wrap.classList.remove('dragging'));
      wrap.addEventListener('dragover', (e)=>{ if (dragState.mode==='section') { e.preventDefault(); wrap.classList.add('drag-over'); }});
      wrap.addEventListener('dragleave', ()=> wrap.classList.remove('drag-over'));
      wrap.addEventListener('drop', (e)=>{ e.preventDefault(); wrap.classList.remove('drag-over'); if (dragState.mode!=='section') return; const from=dragState.srcIndex; const to=sectionIndex; if (from===to) return; const arr=state.config.sections; const [m]=arr.splice(from,1); arr.splice(to,0,m); renderSections(); });
      return wrap;
    }

    function createSimpleSection(key, title, sectionIndex, isSection) {
      if (!Array.isArray(state.config[key])) state.config[key] = [];
      const wrap = h('div', { class: 'category', draggable: isSection ? 'true' : 'false' });
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [
          isSection ? h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', onmousedown: () => { dragState.allowed = true; } }) : document.createTextNode(''),
          h('div', { text: title, style: 'font-weight:600;' })
        ]),
        h('div', {}, [ h('button', { class: 'btn small', onclick: () => addSimple(key) }, ['+ æ·»åŠ ']) ])
      ]);

      const table = h('table', { class: 'tags-table fixed' });
      const thead = h('thead', {}, [
        h('tr', {}, [
          h('th', { class: 'col-handle', text: ' ' }),
          h('th', { class: 'col-name', text: 'åç§°' }),
          h('th', { class: 'col-op', text: 'æ“ä½œ' })
        ])
      ]);
      const tbody = h('tbody');
      state.config[key].forEach((item, idx) => {
        const tr = h('tr', { class: 'simple-row', draggable: 'true', 'data-key': key }, [
          h('td', { class: 'col-handle' }, [ h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', onmousedown: () => { dragState.allowed = true; dragState.simpleKey = key; } }) ]),
          h('td', { class: 'col-name' }, [ h('input', { type: 'text', value: item.label || '', placeholder: 'åç§°', style: 'width:80%;', oninput: (e) => { item.label = e.target.value; item.value = e.target.value; } }) ]),
          h('td', { class: 'col-op' }, [ h('button', { class: 'btn danger small', onclick: () => removeSimple(key, idx) }, ['åˆ é™¤']) ])
        ]);
        tbody.appendChild(tr);
      });
      table.appendChild(thead);
      table.appendChild(tbody);

      wrap.appendChild(head);
      wrap.appendChild(table);

      if (isSection) {
        wrap.addEventListener('dragstart', (e) => { if (!dragState.allowed) { e.preventDefault(); return; } dragState.mode='section'; dragState.srcIndex = sectionIndex; wrap.classList.add('dragging'); setTimeout(()=>{dragState.allowed=false;},0); });
        wrap.addEventListener('dragend', ()=> wrap.classList.remove('dragging'));
        wrap.addEventListener('dragover', (e)=>{ if (dragState.mode==='section') { e.preventDefault(); wrap.classList.add('drag-over'); }});
        wrap.addEventListener('dragleave', ()=> wrap.classList.remove('drag-over'));
        wrap.addEventListener('drop', (e)=>{ e.preventDefault(); wrap.classList.remove('drag-over'); if (dragState.mode!=='section') return; const from=dragState.srcIndex; const to=sectionIndex; if (from===to) return; const arr=state.config.sections; const [m]=arr.splice(from,1); arr.splice(to,0,m); renderSections(); });
      }
      return wrap;
    }

  function renderCustomSectionByTitle(title, sectionIndex) {
    if (!Array.isArray(state.config.customSections)) state.config.customSections = [];
    let sec = state.config.customSections.find(s => s && s.title === title);
    if (!sec) { sec = { title, multiple: true, items: [] }; state.config.customSections.push(sec); }
    const wrap = h('div', { class: 'category', draggable: 'true' });
    const toggleBtn = h('button', { class: 'collapse-toggle', title: 'æ”¶èµ·/å±•å¼€' }, ['â–¼']);
    const head = h('div', { class: 'category-head' }, [
      h('div', { class: 'row' }, [
        toggleBtn,
        h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', onmousedown: () => { dragState.allowed = true; } }),
        h('input', { type: 'text', value: sec.title || '', placeholder: 'æ¿å—åç§°', style: 'width:240px;', oninput: (e) => { const old = sec.title; sec.title = e.target.value; const idx = state.config.sections.indexOf('custom:'+old); if (idx>=0) state.config.sections[idx] = 'custom:'+sec.title; } })
      ]),
      h('div', {}, [ 
        h('button', { class: 'btn danger small', onclick: () => { const idx = state.config.sections.indexOf('custom:'+sec.title); if (idx>=0) state.config.sections.splice(idx,1); const si = state.config.customSections.indexOf(sec); if (si>=0) state.config.customSections.splice(si,1); renderSections(); } }, ['åˆ é™¤æ¿å—']) 
      ])
    ]);
    
    const settingRow = h('div', { class: 'row', style: 'margin-top:8px; align-items:center; gap:10px; flex-wrap:wrap;' }, [
      h('label', {}, [
        h('input', { class: 'big-check', type: 'checkbox', checked: sec.multiple !== false, onchange: (e) => { sec.multiple = e.target.checked; } }),
        document.createTextNode(' å¯å¤šé€‰')
      ]),
      h('span', { text: 'æ˜¾ç¤ºæ¡ä»¶ï¼ˆå¯é€‰ï¼‰ï¼š', style: 'margin-left:16px; color:#876; font-size:13px;' }),
      h('input', { type: 'text', value: sec.showIf || '', placeholder: 'å¦‚ æ€§å‘:GB', style: 'width:180px;', oninput: (e) => { sec.showIf = e.target.value.trim() || undefined; } })
    ]);

    const table = h('table', { class: 'tags-table' });
    const thead = h('thead', {}, [ 
      h('tr', {}, [ 
        h('th', { class: 'col-handle', text: ' ' }), 
        h('th', { text: 'åç§°' }), 
        h('th', { text: 'å¯ç”¨æ¡ä»¶ (|æˆ– !é)', style: 'width:200px;' }), 
        h('th', { text: 'äº’æ–¥é¡¹', style: 'width:140px;' }), 
        h('th', { class: 'right', text: 'æ“ä½œ', style: 'width:80px;' }) 
      ]) 
    ]);
    const tbody = h('tbody');
    (sec.items || []).forEach((item, idx) => {
      const tr = h('tr', { class: 'simple-row', draggable: 'true', 'data-key': 'section-'+sec.title }, [
        h('td', { class: 'col-handle' }, [ h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', onmousedown: () => { dragState.allowed = true; dragState.simpleKey = 'section-'+sec.title; } }) ]),
        h('td', {}, [ h('input', { type: 'text', value: item.label || '', placeholder: 'åç§°', style: 'width:100%;', oninput: (e) => { item.label = e.target.value; item.value = e.target.value; } }) ]),
        h('td', {}, [ h('input', { type: 'text', value: item.enableIf || '', placeholder: '!æ€§å‘:æ— CP|æ€§å‘:GB', style: 'width:100%;', oninput: (e) => { item.enableIf = e.target.value.trim() || undefined; } }) ]),
        h('td', {}, [ h('input', { type: 'text', value: (item.mutexWith || []).join(','), placeholder: 'å¦‚ åŸåˆ›,åŒäºº', style: 'width:100%;', oninput: (e) => { const v = e.target.value.trim(); item.mutexWith = v ? v.split(',').map(x => x.trim()).filter(Boolean) : undefined; } }) ]),
        h('td', { class: 'right' }, [ h('button', { class: 'btn danger small', onclick: () => { sec.items.splice(idx,1); renderSections(); } }, ['åˆ é™¤']) ])
      ]);
      tbody.appendChild(tr);
    });
    table.appendChild(thead); table.appendChild(tbody);
    
    const footer = h('div', { style: 'text-align:right; margin-top:8px;' }, [
      h('button', { class: 'add-tag-btn', onclick: () => { (sec.items || (sec.items=[])).push({ label: '', value: '' }); renderSections(); } }, ['+'])
    ]);
    
    const contentWrap = h('div');
    contentWrap.appendChild(settingRow);
    contentWrap.appendChild(table);
    contentWrap.appendChild(footer);
    toggleBtn.onclick = () => { 
      const hidden = contentWrap.classList.toggle('hidden'); 
      toggleBtn.classList.toggle('collapsed', hidden);
    };
    wrap.appendChild(head);
    wrap.appendChild(contentWrap);
    // section æ‹–æ‹½æ”¯æŒ
    wrap.addEventListener('dragstart', (e) => { if (!dragState.allowed) { e.preventDefault(); return; } dragState.mode='section'; dragState.srcIndex = sectionIndex; wrap.classList.add('dragging'); setTimeout(()=>{dragState.allowed=false;},0); });
    wrap.addEventListener('dragend', ()=> wrap.classList.remove('dragging'));
    wrap.addEventListener('dragover', (e)=>{ if (dragState.mode==='section') { e.preventDefault(); wrap.classList.add('drag-over'); }});
    wrap.addEventListener('dragleave', ()=> wrap.classList.remove('drag-over'));
    wrap.addEventListener('drop', (e)=>{ e.preventDefault(); wrap.classList.remove('drag-over'); if (dragState.mode!=='section') return; const from=dragState.srcIndex; const to=sectionIndex; if (from===to) return; const arr=state.config.sections; const [m]=arr.splice(from,1); arr.splice(to,0,m); renderSections(); });
    return wrap;
  }

    function addSimple(key) {
      if (!Array.isArray(state.config[key])) state.config[key] = [];
      state.config[key].push({ label: '', value: '' });
      renderSections();
    }

    function removeSimple(key, idx) {
      state.config[key].splice(idx, 1);
      renderSections();
    }

  function renderPartitions(targetHost) {
    const host = targetHost || document.getElementById('partitions');
    if (!host) return;
    host.innerHTML = '';
    const keys = [
      { k: 'common', name: 'å…¬å…±' },
      { k: 'feibianxian', name: 'éè¾¹é™' },
      { k: 'bianxian', name: 'è¾¹é™' },
      { k: 'shenyuan', name: 'æ·±æ¸Š' }
    ];
    if (!state.config.tagPartitions) state.config.tagPartitions = {};
    
    // æ¯æ¬¡æ¸²æŸ“æ—¶ä» localStorage è¯»å–æœ€æ–°çŠ¶æ€
    if (!window.partitionCollapseStates) {
      window.partitionCollapseStates = {};
    }
    keys.forEach(({ k }) => {
      const saved = localStorage.getItem(`partition_${k}_collapsed`);
      window.partitionCollapseStates[k] = saved === 'true';
    });
    
    keys.forEach(({ k, name }) => {
      const section = h('div', { class: 'category', style: 'margin-top:12px;' });
      const toggleBtn = h('button', { class: 'collapse-toggle', title: 'æ”¶èµ·/å±•å¼€' }, ['â–¼']);
      const list = h('div', { class: 'grid' });
      
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [ 
          toggleBtn,
          h('div', { text: name, style: 'font-weight:600;' }) 
        ]),
        h('div', {}, [ h('button', { class: 'btn small', onclick: () => addPartitionCategory(k) }, ['+ æ·»åŠ åˆ†ç±»']) ])
      ]);
      
      const arr = Array.isArray(state.config.tagPartitions[k]) ? state.config.tagPartitions[k] : (state.config.tagPartitions[k] = []);
      arr.forEach((cat, idx) => list.appendChild(renderCategory(cat, idx, { scope: 'partition', key: k })));
      
      // åº”ç”¨æŠ˜å çŠ¶æ€
      const isCollapsed = window.partitionCollapseStates[k];
      if (isCollapsed) {
        list.classList.add('hidden');
        toggleBtn.classList.add('collapsed');
      }
      
      // ç»‘å®šæŠ˜å æŒ‰é’®
      toggleBtn.onclick = () => {
        const hidden = list.classList.toggle('hidden');
        toggleBtn.classList.toggle('collapsed', hidden);
        window.partitionCollapseStates[k] = hidden;
        localStorage.setItem(`partition_${k}_collapsed`, String(hidden));
      };
      
      section.appendChild(head);
      section.appendChild(list);
      host.appendChild(section);
    });
  }

    function addPartitionCategory(key) {
      if (!state.config.tagPartitions) state.config.tagPartitions = {};
      const arr = Array.isArray(state.config.tagPartitions[key]) ? state.config.tagPartitions[key] : (state.config.tagPartitions[key] = []);
      arr.push({ category: 'æ–°åˆ†ç±»', asPill: false, tags: [] });
      renderPartitions();
    }

  function renderCategory(cat, index, ctx) {
      const scope = (ctx && ctx.scope === 'partition') ? 'partition' : 'normal';
      const box = h('div', { class: 'category', draggable: 'true', 'data-scope': scope, 'data-index': String(index), 'data-partition-key': (scope === 'partition' ? (ctx && ctx.key || '') : '') });
      const toggleBtn = h('button', { class: 'collapse-toggle', title: 'æ”¶èµ·/å±•å¼€' }, ['â–¼']);
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [
          toggleBtn,
          h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', 'data-role': 'cat-handle', onmousedown: () => { dragState.allowed = true; } }),
          h('input', { type: 'text', value: cat.category || '', placeholder: 'åˆ†ç±»åç§°', style: 'width:240px;', oninput: (e) => { cat.category = e.target.value; } })
        ]),
        h('div', {}, [
          h('button', { class: 'btn small', onclick: () => { 
            if (!Array.isArray(cat.tags)) cat.tags = []; 
            cat.tags.push({ label: '', value: '' }); 
            (ctx && ctx.scope === 'partition') ? renderPartitions() : renderCategories(); 
          } }, ['+ æ·»åŠ æ ‡ç­¾']),
          h('span', { text: ' ' }),
          h('button', { class: 'btn danger small', onclick: () => { if (ctx && ctx.scope === 'partition') { const arr = (state.config.tagPartitions && state.config.tagPartitions[ctx.key]) || []; arr.splice(index, 1); renderPartitions(); } else { state.config.tagCategories.splice(index, 1); renderCategories(); } } }, ['åˆ é™¤åˆ†ç±»'])
        ])
      ]);

      const table = h('table', { class: 'tags-table' });
      const thead = h('thead', {}, [
        h('tr', {}, [
          h('th', { class: 'col-handle', text: ' ' }),
          h('th', { text: 'æ˜¾ç¤ºå' }),
          h('th', { text: 'å¯ç”¨æ¡ä»¶ (|æˆ– !é)', style: 'width:180px;' }),
          h('th', { text: 'äº’æ–¥é¡¹', style: 'width:120px;' }),
          h('th', { class: 'right', text: 'æ“ä½œ', style: 'width:70px;' })
        ])
      ]);
      const tbody = h('tbody');
      (Array.isArray(cat.tags) ? cat.tags : []).forEach((tag, tIdx) => {
        const tr = h('tr', { class: 'tag-row', draggable: 'true' }, [
          h('td', { class: 'col-handle' }, [ h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', onmousedown: () => { dragState.allowed = true; dragState.tagCatIndex = index; } }) ]),
          h('td', {}, [h('input', { type: 'text', value: tag.label || '', placeholder: 'å¦‚ æ ¡å›­', style: 'width:100%;', oninput: (e) => { tag.label = e.target.value; tag.value = e.target.value; } })]),
          h('td', {}, [h('input', { type: 'text', value: tag.showIf || '', placeholder: '!æ€§å‘:æ— CP|æ€§å‘:GB', style: 'width:100%;', oninput: (e) => { tag.showIf = e.target.value.trim() || undefined; } })]),
          h('td', {}, [h('input', { type: 'text', value: (tag.mutexWith || []).join(','), placeholder: 'å¦‚ éƒ½å¸‚,å¤ä»£', style: 'width:100%;', oninput: (e) => { const v = e.target.value.trim(); tag.mutexWith = v ? v.split(',').map(x => x.trim()).filter(Boolean) : undefined; } })]),
          h('td', { class: 'right' }, [h('button', { class: 'btn danger small', onclick: () => { cat.tags.splice(tIdx, 1); (ctx && ctx.scope === 'partition') ? renderPartitions() : renderCategories(); } }, ['åˆ é™¤'])])
        ]);
        tbody.appendChild(tr);
      });
      table.appendChild(thead);
      table.appendChild(tbody);

      // åˆ†ç±»è®¾ç½®ï¼šæ˜¯å¦ä½œä¸ºæ•´ç±»å¯å•ç‹¬ç‚¹é€‰ï¼ˆèƒ¶å›Šï¼‰+ åˆ†ç±»çº§åˆ«çš„æ¡ä»¶å’Œäº’æ–¥
      const pillRow = h('div', { class: 'row', style: 'margin-top:8px; align-items:center; gap:10px; flex-wrap:wrap;' }, [
        h('label', {}, [
          h('input', { class: 'big-check', type: 'checkbox', checked: !!cat.asPill, onchange: (e) => { 
            cat.asPill = e.target.checked; 
          } }),
          document.createTextNode(' æ•´ç±»å¯ç‚¹é€‰ï¼ˆèƒ¶å›Šï¼‰')
        ]),
        h('span', { text: 'æ˜¾ç¤ºæ¡ä»¶ï¼š', style: 'margin-left:16px; color:#876; font-size:13px;' }),
        h('input', { type: 'text', value: cat.showIf || '', placeholder: 'å¦‚ æ€§å‘:GB', style: 'width:140px;', oninput: (e) => { cat.showIf = e.target.value.trim() || undefined; } }),
        h('span', { text: 'äº’æ–¥ï¼š', style: 'margin-left:8px; color:#876; font-size:13px;' }),
        h('input', { type: 'text', value: (cat.mutexWith || []).join(','), placeholder: 'å¦‚ åœºæ™¯,å…³ç³»', style: 'width:120px;', oninput: (e) => { const v = e.target.value.trim(); cat.mutexWith = v ? v.split(',').map(x => x.trim()).filter(Boolean) : undefined; } })
      ]);

      const tableFooter = h('div', { style: 'text-align: right; margin-top: 8px;' }, [
        h('button', { class: 'add-tag-btn', type: 'button', title: 'æ·»åŠ æ ‡ç­¾', onclick: () => {
          if (!Array.isArray(cat.tags)) cat.tags = [];
          cat.tags.push({ label: '', value: '' });
          (ctx && ctx.scope === 'partition') ? renderPartitions() : renderCategories();
        } }, ['+'])
      ]);

      const contentWrap = h('div');
      contentWrap.appendChild(pillRow);
      contentWrap.appendChild(table);
      contentWrap.appendChild(tableFooter);
      toggleBtn.onclick = () => { 
        const hidden = contentWrap.classList.toggle('hidden'); 
        toggleBtn.classList.toggle('collapsed', hidden);
      };
      box.appendChild(head);
      box.appendChild(contentWrap);

      // --- æ‹–æ‹½ï¼ˆåˆ†ç±»ï¼‰ ---
      box.addEventListener('dragstart', (e) => {
        if (!dragState.allowed) { e.preventDefault(); return; }
        dragState.mode = 'category';
        dragState.srcCat = index;
        e.dataTransfer && (e.dataTransfer.effectAllowed = 'move');
        box.classList.add('dragging');
        // è¿˜åŸ handle æˆæƒæ ‡è®°
        setTimeout(() => { dragState.allowed = false; }, 0);
      });
      box.addEventListener('dragend', () => {
        box.classList.remove('dragging');
        document.querySelectorAll('.category.drag-over').forEach(el => el.classList.remove('drag-over'));
      });
      box.addEventListener('dragover', (e) => {
        if (dragState.mode === 'category') { e.preventDefault(); box.classList.add('drag-over'); }
      });
      box.addEventListener('dragleave', () => { box.classList.remove('drag-over'); });
      box.addEventListener('drop', (e) => {
        e.preventDefault();
        box.classList.remove('drag-over');
        if (dragState.mode !== 'category') return;
        const from = dragState.srcCat;
        const to = index;
        if (from === undefined || to === undefined || from === to) return;
        const arr = (ctx && ctx.scope === 'partition') ? ((state.config.tagPartitions && state.config.tagPartitions[ctx.key]) || []) : (state.config.tagCategories || []);
        const [m] = arr.splice(from, 1);
        arr.splice(to, 0, m);
        setStatus('å·²è°ƒæ•´åˆ†ç±»é¡ºåºï¼ˆæœªä¿å­˜ï¼‰');
        (ctx && ctx.scope === 'partition') ? renderPartitions() : renderCategories();
      });
      return box;
    }

    function addCategory() {
      if (!Array.isArray(state.config.tagCategories)) state.config.tagCategories = [];
      state.config.tagCategories.push({ category: 'æ–°åˆ†ç±»', asPill: false, tags: [] });
      renderCategories();
    }
  

    // --- æ‹–æ‹½ï¼ˆæ ‡ç­¾è¡Œï¼‰ ---
    document.addEventListener('dragstart', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (!tr) return;
      if (!dragState.allowed) { e.preventDefault(); return; }
      const tbody = tr.parentElement;
      const catBox = tr.closest('.category');
      const catIndex = catBox ? parseInt(catBox.getAttribute('data-index') || '-1', 10) : -1;
      const rows = Array.from(tbody.querySelectorAll('tr.tag-row'));
      const rowIndex = rows.indexOf(tr);
      dragState.mode = 'tag';
      dragState.srcCat = catIndex;
      dragState.srcTag = rowIndex;
      dragState.scope = catBox ? catBox.getAttribute('data-scope') : 'normal';
      dragState.partitionKey = catBox ? catBox.getAttribute('data-partition-key') : '';
      e.dataTransfer && (e.dataTransfer.effectAllowed = 'move');
      tr.classList.add('dragging');
      setTimeout(() => { dragState.allowed = false; }, 0);
    });
    document.addEventListener('dragend', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (tr) tr.classList.remove('dragging');
      document.querySelectorAll('tr.tag-row.drag-over').forEach(el => el.classList.remove('drag-over'));
    });
    document.addEventListener('dragover', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (!tr) return;
      if (dragState.mode === 'tag') { e.preventDefault(); tr.classList.add('drag-over'); }
    });
    document.addEventListener('dragleave', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (tr) tr.classList.remove('drag-over');
    });
    document.addEventListener('drop', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (!tr) return;
      e.preventDefault();
      tr.classList.remove('drag-over');
      if (dragState.mode !== 'tag') return;
      // ä»…é™åŒåˆ†ç±»å†…æ’åº
      const targetCatBox = tr.closest('.category');
      const targetCatIndex = targetCatBox ? parseInt(targetCatBox.getAttribute('data-index') || '-1', 10) : -1;
      if (targetCatIndex !== dragState.srcCat) return;
      const rows = Array.from(tr.parentElement.querySelectorAll('tr.tag-row'));
      const to = rows.indexOf(tr);
      const from = dragState.srcTag;
      if (from === undefined || to === undefined || from === to) return;
      let cat;
      if (dragState.scope === 'partition') {
        const arr = (state.config.tagPartitions && state.config.tagPartitions[dragState.partitionKey]) || [];
        cat = arr[targetCatIndex];
      } else {
        cat = (state.config.tagCategories || [])[targetCatIndex];
      }
      if (!cat || !Array.isArray(cat.tags)) return;
      const [m] = cat.tags.splice(from, 1);
      cat.tags.splice(to, 0, m);
      setStatus('å·²è°ƒæ•´æ ‡ç­¾é¡ºåºï¼ˆæœªä¿å­˜ï¼‰');
      (dragState.scope === 'partition') ? renderPartitions() : renderCategories();
    });

    // å…¨å±€å…œåº•æ¸…ç†æ‹–æ‹½æ ·å¼ï¼Œé¿å…æ®‹ç•™åŠé€æ˜è’™ç‰ˆ
    document.addEventListener('dragend', () => {
      document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
      document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
      dragState.mode = null; dragState.allowed = false;
    });
    document.addEventListener('drop', () => {
      document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
      document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
      dragState.mode = null; dragState.allowed = false;
    });

    // --- è§¦æ‘¸ç«¯ï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰å¯¹æ ‡ç­¾è¡Œçš„æ’åºé™çº§æ”¯æŒ ---
    let touchScrollBlock = false;
    document.addEventListener('touchstart', (e) => {
      const handle = e.target && e.target.closest && e.target.closest('tr.tag-row .drag-handle');
      if (!handle) return;
      const tr = handle.closest('tr.tag-row');
      if (!tr) return;
      const catBox = tr.closest('.category');
      dragState.mode = 'touch-tag';
      dragState.touchActive = true;
      dragState.srcRow = tr;
      dragState.scope = catBox ? catBox.getAttribute('data-scope') : 'normal';
      dragState.partitionKey = catBox ? catBox.getAttribute('data-partition-key') : '';
      dragState.srcCat = catBox ? parseInt(catBox.getAttribute('data-index') || '-1', 10) : -1;
      const rows = Array.from(tr.parentElement.querySelectorAll('tr.tag-row'));
      dragState.srcTag = rows.indexOf(tr);
      tr.classList.add('dragging');
      touchScrollBlock = true;
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (!dragState.touchActive) return;
      const t = e.touches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      const over = el && el.closest && el.closest('tr.tag-row');
      document.querySelectorAll('tr.tag-row.drag-over').forEach(x => x.classList.remove('drag-over'));
      if (over && over.parentElement === dragState.srcRow.parentElement) {
        over.classList.add('drag-over');
        dragState.touchOverRow = over;
      }
      if (touchScrollBlock) e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', () => {
      if (!dragState.touchActive) return;
      const srcRow = dragState.srcRow;
      const overRow = dragState.touchOverRow;
      const rows = Array.from(srcRow.parentElement.querySelectorAll('tr.tag-row'));
      const from = dragState.srcTag;
      const to = overRow ? rows.indexOf(overRow) : from;
      srcRow.classList.remove('dragging');
      if (overRow) overRow.classList.remove('drag-over');
      dragState.touchActive = false;
      touchScrollBlock = false;
      if (from === undefined || to === undefined || from === to) return;
      let cat;
      if (dragState.scope === 'partition') {
        const arr = (state.config.tagPartitions && state.config.tagPartitions[dragState.partitionKey]) || [];
        cat = arr[dragState.srcCat];
      } else {
        cat = (state.config.tagCategories || [])[dragState.srcCat];
      }
      if (!cat || !Array.isArray(cat.tags)) return;
      const [m] = cat.tags.splice(from, 1);
      cat.tags.splice(to, 0, m);
      setStatus('å·²è°ƒæ•´æ ‡ç­¾é¡ºåºï¼ˆæœªä¿å­˜ï¼‰');
      (dragState.scope === 'partition') ? renderPartitions() : renderCategories();
    });

    // --- æ‹–æ‹½ï¼ˆç®€å•æ•°ç»„ï¼šæ€§å‘/èƒŒæ™¯/é™åˆ¶ + è‡ªå®šä¹‰æ¿å—æ¡ç›®ï¼‰ ---
    document.addEventListener('dragstart', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (!tr) return;
      if (!dragState.allowed) { 
        console.log('âŒ æ‹–æ‹½è¢«é˜»æ­¢: dragState.allowed =', dragState.allowed);
        e.preventDefault(); 
        return; 
      }
      const key = tr.getAttribute('data-key');
      console.log('âœ… å¼€å§‹æ‹–æ‹½ simple-row, key =', key);
      const rows = Array.from(tr.parentElement.querySelectorAll('tr.simple-row'));
      dragState.mode = 'simple';
      dragState.simpleKey = key;
      dragState.srcIndex = rows.indexOf(tr);
      console.log('   è®¾ç½® simpleKey =', dragState.simpleKey, 'srcIndex =', dragState.srcIndex);
      e.dataTransfer && (e.dataTransfer.effectAllowed = 'move');
      tr.classList.add('dragging');
      setTimeout(() => { dragState.allowed = false; }, 0);
    });
    document.addEventListener('dragend', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (tr) tr.classList.remove('dragging');
      document.querySelectorAll('tr.simple-row.drag-over').forEach(el => el.classList.remove('drag-over'));
    });
    document.addEventListener('dragover', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (!tr) return;
      if (dragState.mode === 'simple') { e.preventDefault(); tr.classList.add('drag-over'); }
    });
    document.addEventListener('dragleave', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (tr) tr.classList.remove('drag-over');
    });
    document.addEventListener('drop', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (!tr) return;
      e.preventDefault();
      tr.classList.remove('drag-over');
      console.log('ğŸ“ Drop äº‹ä»¶: mode =', dragState.mode);
      if (dragState.mode !== 'simple') return;
      const key = tr.getAttribute('data-key');
      console.log('ğŸ“ Drop key =', key, 'simpleKey =', dragState.simpleKey);
      if (key !== dragState.simpleKey) return;
      const rows = Array.from(tr.parentElement.querySelectorAll('tr.simple-row'));
      const to = rows.indexOf(tr);
      const from = dragState.srcIndex;
      console.log('ğŸ“ Drop ä½ç½®: from =', from, 'to =', to);
      if (from === undefined || to === undefined || from === to) return;
      
      // åˆ¤æ–­æ˜¯è‡ªå®šä¹‰æ¿å—è¿˜æ˜¯æ™®é€šé…ç½®æ•°ç»„
      if (key.startsWith('section-')) {
        console.log('ğŸ”§ å¤„ç†è‡ªå®šä¹‰æ¿å—æ¡ç›®');
        // è‡ªå®šä¹‰æ¿å—çš„æ¡ç›®
        const sectionTitle = key.slice(8); // å»æ‰ 'section-' å‰ç¼€
        console.log('   æ¿å—æ ‡é¢˜:', sectionTitle);
        if (!Array.isArray(state.config.customSections)) {
          console.error('âŒ customSections ä¸å­˜åœ¨');
          return;
        }
        const sec = state.config.customSections.find(s => s && s.title === sectionTitle);
        if (!sec) {
          console.error('âŒ æ‰¾ä¸åˆ°æ¿å—:', sectionTitle);
          console.log('   ç°æœ‰æ¿å—:', state.config.customSections.map(s => s.title));
          return;
        }
        if (!Array.isArray(sec.items)) {
          console.error('âŒ æ¿å— items ä¸æ˜¯æ•°ç»„:', sectionTitle);
          return;
        }
        console.log('âœ… å¼€å§‹è°ƒæ•´é¡ºåº');
        const [m] = sec.items.splice(from, 1);
        sec.items.splice(to, 0, m);
        setStatus('å·²è°ƒæ•´é¡ºåºï¼ˆæœªä¿å­˜ï¼‰');
        renderSections();
      } else {
        console.log('ğŸ”§ å¤„ç†æ™®é€šé…ç½®æ•°ç»„');
        // æ™®é€šé…ç½®æ•°ç»„ï¼ˆå¦‚æ€§å‘ã€èƒŒæ™¯ç­‰ï¼‰
        const arr = state.config[key];
        if (!Array.isArray(arr)) return;
        const [m] = arr.splice(from, 1);
        arr.splice(to, 0, m);
        setStatus('å·²è°ƒæ•´é¡ºåºï¼ˆæœªä¿å­˜ï¼‰');
        renderSections();
      }
    });

  function renderCustomSections() {
    const host = document.getElementById('customSections');
    host.innerHTML = '';
    if (!Array.isArray(state.config.customSections)) state.config.customSections = [];
    state.config.customSections.forEach((sec, sIdx) => {
      const box = h('div', { class: 'category', style: 'margin-top:12px;' });
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [
          h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', onmousedown: () => { dragState.allowed = true; } }),
          h('input', { type: 'text', value: sec.title || '', placeholder: 'æ¿å—åç§°ï¼Œå¦‚ï¼šé¢˜æ', style: 'width:240px;', oninput: (e) => { sec.title = e.target.value; } })
        ]),
        h('div', {}, [
          h('button', { class: 'btn danger small', onclick: () => { state.config.customSections.splice(sIdx, 1); renderCustomSections(); } }, ['åˆ é™¤æ¿å—'])
        ])
      ]);

      const table = h('table', { class: 'tags-table fixed' });
      const thead = h('thead', {}, [
        h('tr', {}, [
          h('th', { class: 'col-handle', text: ' ' }),
          h('th', { class: 'col-name', text: 'åç§°' }),
          h('th', { class: 'col-op', text: 'æ“ä½œ' })
        ])
      ]);
      const tbody = h('tbody');
      (Array.isArray(sec.items) ? sec.items : (sec.items = [])).forEach((item, iIdx) => {
        const tr = h('tr', { class: 'simple-row', draggable: 'true', 'data-key': `section-${sIdx}` }, [
          h('td', { class: 'col-handle' }, [ h('span', { class: 'drag-handle', title: 'æ‹–åŠ¨æ’åº', onmousedown: () => { dragState.allowed = true; dragState.simpleKey = `section-${sIdx}`; } }) ]),
          h('td', { class: 'col-name' }, [ h('input', { type: 'text', value: item.label || '', placeholder: 'å¦‚ éƒ½å¸‚', style: 'width:80%;', oninput: (e) => { item.label = e.target.value; item.value = e.target.value; } }) ]),
          h('td', { class: 'col-op' }, [ h('button', { class: 'btn danger small', onclick: () => { sec.items.splice(iIdx, 1); renderCustomSections(); } }, ['åˆ é™¤']) ])
        ]);
        tbody.appendChild(tr);
      });
      table.appendChild(thead);
      table.appendChild(tbody);

      const footer = h('div', { style: 'text-align:right; margin-top:8px;' }, [
        h('button', { class: 'add-tag-btn', onclick: () => { (sec.items || (sec.items = [])).push({ label: '', value: '' }); renderCustomSections(); } }, ['+'])
      ]);

      box.appendChild(head);
      box.appendChild(table);
      box.appendChild(footer);
      host.appendChild(box);
    });
  }

  document.getElementById('addSection').addEventListener('click', () => {
    if (!Array.isArray(state.config.customSections)) state.config.customSections = [];
    let title = 'æ–°æ¿å—';
    let counter = 1;
    while (state.config.customSections.some(s => s.title === title)) {
      title = 'æ–°æ¿å—' + (++counter);
    }
    state.config.customSections.push({ title, multiple: true, items: [] });
    state.config.sections.push('custom:'+title);
    renderSections();
  });

     async function saveConfig() {
       setStatus('ä¿å­˜ä¸­...');
       const token = getToken();
       if (!token) { setStatus('è¯·å…ˆè¾“å…¥å¹¶ä¿å­˜ç®¡ç†å‘˜ Token', true); return; }
       const body = {
         tagCategories: state.config.tagCategories,
         tagPartitions: state.config.tagPartitions,
         customSections: state.config.customSections,
         sections: state.config.sections
       };
       try {
         const res = await fetch('/api/config', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
           body: JSON.stringify(body)
         });
         const data = await res.json();
         if (!res.ok || !data.success) throw new Error(data.message || 'ä¿å­˜å¤±è´¥');
         state.config = data.config;
         normalizeSections();
         renderSections();
         setStatus('å·²ä¿å­˜');
       } catch (e) {
         setStatus('ä¿å­˜å¤±è´¥ï¼š' + e.message, true);
       }
     }

     function renderTagsPreview() {
       const container = document.getElementById('tagsPreview');
       if (!container) return;
       
       const partition = document.getElementById('previewPartition').value;
       const categories = getPreviewCategories(partition);
       
       container.innerHTML = '';
       categories.forEach((cat, catIdx) => {
         const catDiv = h('div', { class: 'preview-category', draggable: 'true', 'data-cat-index': String(catIdx), 'data-partition': partition });
         
         const header = h('div', { class: 'preview-category-header' }, [
           h('span', { class: 'category-name', text: cat.category }),
           h('button', { class: 'quick-add-btn quick-add', title: 'æ·»åŠ æ ‡ç­¾', onclick: () => quickAddTag(partition, catIdx) }, ['+'])
         ]);
         
         const pillGroup = h('div', { class: 'preview-pill-group' });
         
         // å¤§ç±»èƒ¶å›Š
         if (cat.asPill) {
           const label = cat.pillLabel || cat.category;
           const pill = h('div', { class: 'preview-pill preview-pill-lg', draggable: 'false', text: label });
           pillGroup.appendChild(pill);
         }
         
         // å­æ ‡ç­¾
         (cat.tags || []).forEach((tag, tagIdx) => {
           const pill = h('div', { 
             class: 'preview-pill', 
             draggable: 'true', 
             text: tag.label,
             'data-tag-index': String(tagIdx),
             'data-cat-index': String(catIdx)
           });
           
           // å³é”®åˆ é™¤
           pill.addEventListener('contextmenu', (e) => {
             e.preventDefault();
             if (confirm(`ç¡®å®šåˆ é™¤æ ‡ç­¾"${tag.label}"ï¼Ÿ`)) {
               const arr = getPartitionArray(partition);
               const cat = arr[catIdx];
               if (cat && Array.isArray(cat.tags)) {
                 cat.tags.splice(tagIdx, 1);
                 renderTagsPreview();
                 setStatus('å·²åˆ é™¤æ ‡ç­¾ï¼ˆæœªä¿å­˜ï¼‰');
               }
             }
           });
           
           // æ ‡ç­¾æ‹–æ‹½
           pill.addEventListener('dragstart', (e) => {
             previewDragState.mode = 'tag';
             previewDragState.srcCat = catIdx;
             previewDragState.srcTag = tagIdx;
             previewDragState.partition = partition;
             pill.classList.add('dragging');
             e.dataTransfer.effectAllowed = 'move';
           });
           pill.addEventListener('dragend', () => {
             pill.classList.remove('dragging');
             document.querySelectorAll('.preview-pill.drag-over-pill').forEach(el => el.classList.remove('drag-over-pill'));
           });
           pill.addEventListener('dragover', (e) => {
             if (previewDragState.mode === 'tag' && previewDragState.partition === partition) {
               e.preventDefault();
               pill.classList.add('drag-over-pill');
             }
           });
           pill.addEventListener('dragleave', () => pill.classList.remove('drag-over-pill'));
           pill.addEventListener('drop', (e) => {
             e.preventDefault();
             pill.classList.remove('drag-over-pill');
             if (previewDragState.mode !== 'tag' || previewDragState.partition !== partition) return;
             const toCat = catIdx;
             const toTag = tagIdx;
             if (previewDragState.srcCat === toCat && previewDragState.srcTag === toTag) return;
             
             // åŒåˆ†ç±»å†…æ’åº
             if (previewDragState.srcCat === toCat) {
               const arr = getPartitionArray(partition);
               const cat = arr[toCat];
               if (!cat || !Array.isArray(cat.tags)) return;
               const [moved] = cat.tags.splice(previewDragState.srcTag, 1);
               cat.tags.splice(toTag, 0, moved);
               renderTagsPreview();
               setStatus('å·²è°ƒæ•´æ ‡ç­¾é¡ºåºï¼ˆæœªä¿å­˜ï¼‰');
             }
           });
           
           pillGroup.appendChild(pill);
         });
         
         catDiv.appendChild(header);
         catDiv.appendChild(pillGroup);
         
         // åˆ†ç±»æ‹–æ‹½
         catDiv.addEventListener('dragstart', (e) => {
           if (e.target.classList.contains('preview-pill')) return;
           previewDragState.mode = 'category';
           previewDragState.srcCat = catIdx;
           previewDragState.partition = partition;
           catDiv.classList.add('dragging');
           e.dataTransfer.effectAllowed = 'move';
         });
         catDiv.addEventListener('dragend', () => {
           catDiv.classList.remove('dragging');
           document.querySelectorAll('.preview-category.drag-over-cat').forEach(el => el.classList.remove('drag-over-cat'));
         });
         catDiv.addEventListener('dragover', (e) => {
           if (previewDragState.mode === 'category' && previewDragState.partition === partition) {
             e.preventDefault();
             catDiv.classList.add('drag-over-cat');
           }
         });
         catDiv.addEventListener('dragleave', () => catDiv.classList.remove('drag-over-cat'));
         catDiv.addEventListener('drop', (e) => {
           e.preventDefault();
           catDiv.classList.remove('drag-over-cat');
           if (previewDragState.mode !== 'category' || previewDragState.partition !== partition) return;
           const from = previewDragState.srcCat;
           const to = catIdx;
           if (from === to) return;
           
           const arr = getPartitionArray(partition);
           const [moved] = arr.splice(from, 1);
           arr.splice(to, 0, moved);
           renderTagsPreview();
           setStatus('å·²è°ƒæ•´åˆ†ç±»é¡ºåºï¼ˆæœªä¿å­˜ï¼‰');
         });
         
         container.appendChild(catDiv);
       });
     }
     
     function getPreviewCategories(partition) {
       const partitions = (state.config.tagPartitions || {});
       const common = Array.isArray(partitions.common) ? partitions.common : [];
       const extra = partition && Array.isArray(partitions[partition]) ? partitions[partition] : [];
       return mergeCategoriesByName(common, extra);
     }
     
     function getPartitionArray(partition) {
       if (!state.config.tagPartitions) state.config.tagPartitions = {};
       const key = partition || 'common';
       if (!Array.isArray(state.config.tagPartitions[key])) state.config.tagPartitions[key] = [];
       return state.config.tagPartitions[key];
     }
     
     function mergeCategoriesByName(base, extra) {
       const byName = new Map();
       const add = (arr) => {
         (arr || []).forEach(cat => {
           if (!cat || !cat.category) return;
           if (!byName.has(cat.category)) {
             byName.set(cat.category, {
               category: cat.category,
               asPill: !!cat.asPill,
               pillLabel: cat.pillLabel,
               pillValue: cat.pillValue,
               showIf: cat.showIf,
               mutexWith: cat.mutexWith,
               tags: []
             });
           }
           const entry = byName.get(cat.category);
           if (cat.asPill) entry.asPill = true;
           if (cat.pillLabel) entry.pillLabel = cat.pillLabel;
           if (cat.pillValue) entry.pillValue = cat.pillValue;
           if (cat.showIf) entry.showIf = cat.showIf;
           if (Array.isArray(cat.mutexWith) && cat.mutexWith.length) entry.mutexWith = cat.mutexWith;
           
           const seen = new Set(entry.tags.map(t => t.value || t.label));
           (cat.tags || []).forEach(t => {
             const val = (t && (t.value || t.label));
             if (!val || seen.has(val)) return;
             entry.tags.push({
               value: t.value || t.label,
               label: t.label || t.value,
               showIf: t.showIf,
               mutexWith: Array.isArray(t.mutexWith) ? t.mutexWith : undefined
             });
             seen.add(val);
           });
         });
       };
       add(base);
       add(extra);
       return Array.from(byName.values());
     }
     
     function quickAddTag(partition, catIdx) {
       const name = prompt('è¾“å…¥æ–°æ ‡ç­¾åç§°:');
       if (!name || !name.trim()) return;
       const arr = getPartitionArray(partition);
       const cat = arr[catIdx];
       if (!cat) return;
       if (!Array.isArray(cat.tags)) cat.tags = [];
       cat.tags.push({ label: name.trim(), value: name.trim() });
       renderTagsPreview();
       setStatus('å·²æ·»åŠ æ ‡ç­¾ï¼ˆæœªä¿å­˜ï¼‰');
     }
     
     const previewDragState = { mode: null, srcCat: null, srcTag: null, partition: '' };

    // æ‹–æ‹½çŠ¶æ€
    const dragState = { mode: null, srcCat: null, srcTag: null, allowed: false, tagCatIndex: null, simpleKey: null, srcIndex: null, scope: 'normal', partitionKey: '', touchActive: false, srcRow: null, touchOverRow: null };

    // UI wiring
    document.getElementById('saveConfig').addEventListener('click', saveConfig);
    document.getElementById('saveConfig2').addEventListener('click', saveConfig);
    document.getElementById('reloadConfig').addEventListener('click', () => loadConfig().then(() => setStatus('å·²é‡æ–°åŠ è½½')).catch(e => setStatus('åŠ è½½å¤±è´¥ï¼š' + e.message, true)));
    document.getElementById('reloadConfig2').addEventListener('click', () => loadConfig().then(() => setStatus('å·²é‡æ–°åŠ è½½')).catch(e => setStatus('åŠ è½½å¤±è´¥ï¼š' + e.message, true)));

    document.getElementById('toggleToken').addEventListener('click', () => {
      const el = document.getElementById('adminToken');
      el.type = el.type === 'password' ? 'text' : 'password';
    });
    document.getElementById('saveToken').addEventListener('click', () => {
      const v = (document.getElementById('adminToken').value || '').trim();
      if (v) localStorage.setItem('admin_token', v);
      setStatus('Token å·²ä¿å­˜åœ¨æœ¬åœ°');
    });
    document.getElementById('clearToken').addEventListener('click', () => {
      localStorage.removeItem('admin_token');
      document.getElementById('adminToken').value = '';
      setStatus('Token å·²æ¸…é™¤');
    });
    document.getElementById('enterAdmin').addEventListener('click', () => {
      const token = getToken();
      if (!token) { setStatus('è¯·è¾“å…¥ Token', true); return; }
      localStorage.setItem('admin_token', token);
      document.getElementById('guardCard').classList.add('hidden');
      document.getElementById('editor').classList.remove('hidden');
      loadConfig().catch(e => setStatus('åŠ è½½å¤±è´¥ï¼š' + e.message, true));
    });

    // é¢„è§ˆç•Œé¢æ§åˆ¶
    let previewExpanded = localStorage.getItem('preview_expanded') !== 'false';
    
    function updatePreviewSize() {
      const container = document.getElementById('tagsPreview');
      if (previewExpanded) {
        container.classList.remove('collapsed');
      } else {
        container.classList.add('collapsed');
      }
      localStorage.setItem('preview_expanded', previewExpanded);
    }
    
    document.getElementById('togglePreviewSize').addEventListener('click', () => {
      previewExpanded = !previewExpanded;
      updatePreviewSize();
    });
    
    document.getElementById('previewPartition').addEventListener('change', () => {
      renderTagsPreview();
    });
    
    document.getElementById('addPreviewCategory').addEventListener('click', () => {
      const name = prompt('è¾“å…¥æ–°åˆ†ç±»åç§°:');
      if (!name || !name.trim()) return;
      const partition = document.getElementById('previewPartition').value || 'common';
      const arr = getPartitionArray(partition);
      arr.push({ category: name.trim(), asPill: false, tags: [] });
      renderTagsPreview();
      setStatus('å·²æ·»åŠ åˆ†ç±»ï¼ˆæœªä¿å­˜ï¼‰');
    });
    
    document.getElementById('savePreview').addEventListener('click', async () => {
      setStatus('ä¿å­˜é¢„è§ˆæ›´æ”¹ä¸­...');
      const token = getToken();
      if (!token) { setStatus('è¯·å…ˆè¾“å…¥å¹¶ä¿å­˜ç®¡ç†å‘˜ Token', true); return; }
      const body = {
        tagCategories: state.config.tagCategories,
        tagPartitions: state.config.tagPartitions,
        customSections: state.config.customSections,
        sections: state.config.sections
      };
      try {
        const res = await fetch('/api/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
          body: JSON.stringify(body)
        });
        const data = await res.json();
        if (!res.ok || !data.success) throw new Error(data.message || 'ä¿å­˜å¤±è´¥');
        state.config = data.config;
        normalizeSections();
        renderSections();
        setStatus('é¢„è§ˆæ›´æ”¹å·²ä¿å­˜');
      } catch (e) {
        setStatus('ä¿å­˜å¤±è´¥ï¼š' + e.message, true);
      }
    });

    // Init
    (function init() {
      const saved = localStorage.getItem('admin_token');
      if (saved) {
        document.getElementById('adminToken').value = saved;
        document.getElementById('guardCard').classList.add('hidden');
        document.getElementById('editor').classList.remove('hidden');
        loadConfig().then(() => {
          renderTagsPreview();
          updatePreviewSize();
        }).catch(e => setStatus('åŠ è½½å¤±è´¥ï¼š' + e.message, true));
      }
    })();
  </script>
</body>
</html>


