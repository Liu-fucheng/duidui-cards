<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ•°æ®åº“ç¼–è¾‘ç®¡ç†</title>
  <style>
    :root {
      --bg: #F3E9DD;
      --surface: #FAF4EC;
      --text: #5C4033;
      --muted: #D9CBBE;
      --accent: #8B5E3C;
      --success: #4CAF50;
      --warning: #FF9800;
      --danger: #B5534E;
    }

    * { box-sizing: border-box; }
    html, body { 
      background: var(--bg); 
      color: var(--text); 
      font-family: ui-sans-serif, -apple-system, sans-serif; 
      margin: 0;
      padding: 0;
    }
    body { 
      margin: 24px; 
      max-width: 1600px; 
      margin-left: auto; 
      margin-right: auto; 
    }
    h1 { font-size: 28px; margin: 0 0 20px; }
    h2 { font-size: 20px; margin: 20px 0 12px; }
    .card { 
      background: var(--surface); 
      border: 1px solid var(--muted); 
      border-radius: 12px; 
      padding: 20px; 
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05); 
    }
    .btn { 
      display: inline-flex; 
      align-items: center; 
      gap: 6px; 
      padding: 10px 18px; 
      border-radius: 10px; 
      border: 1px solid var(--muted); 
      background: var(--surface); 
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    .btn:hover { background: #fff; }
    .btn.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    .btn.primary:hover { background: #6d4a2e; }
    .btn.danger { background: var(--danger); color: #fff; border-color: var(--danger); }
    .btn.success { background: var(--success); color: #fff; border-color: var(--success); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    input[type="password"], input[type="text"], input[type="number"], 
    textarea, select { 
      padding: 8px 12px; 
      border: 1px solid var(--muted); 
      border-radius: 8px; 
      background: #fff; 
      color: var(--text);
      font-size: 14px;
      font-family: inherit;
      width: 100%;
    }
    
    textarea {
      min-height: 80px;
      resize: vertical;
    }
    
    .flex { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .flex-between { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px; }
    
    .status { 
      padding: 12px; 
      border-radius: 8px; 
      margin: 12px 0; 
      font-weight: 500;
    }
    .status.success { background: #e8f5e9; color: #2e7d32; border: 1px solid #4caf50; }
    .status.error { background: #ffebee; color: #c62828; border: 1px solid #f44336; }
    .status.warning { background: #fff3e0; color: #e65100; border: 1px solid #ff9800; }
    .status.info { background: #e3f2fd; color: #1565c0; border: 1px solid #2196f3; }
    
    .hidden { display: none; }
    
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .form-group.full-width {
      grid-column: 1 / -1;
    }
    
    .form-label {
      font-weight: 600;
      font-size: 13px;
      color: #876;
    }
    
    .form-help {
      font-size: 12px;
      color: #999;
      margin-top: -4px;
    }
    
    .search-bar {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 16px;
      padding: 16px;
      background: #fff;
      border-radius: 8px;
      border: 1px solid var(--muted);
    }
    
    .search-bar input {
      flex: 1;
      min-width: 200px;
    }
    
    .card-list {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid var(--muted);
      border-radius: 8px;
      background: #fff;
    }
    
    .card-item {
      padding: 12px 16px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .card-item:hover {
      background: #f9f6f2;
    }
    
    .card-item.selected {
      background: #e8f0fe;
      border-left: 3px solid var(--accent);
    }
    
    .card-item-title {
      font-weight: 600;
      margin-bottom: 4px;
    }
    
    .card-item-meta {
      font-size: 12px;
      color: #876;
    }
    
    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--muted);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.6s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .field-type-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      background: #e0e0e0;
      color: #666;
      margin-left: 8px;
    }
    
    .field-type-badge.json { background: #fff3e0; color: #e65100; }
    .field-type-badge.integer { background: #e3f2fd; color: #1565c0; }
    .field-type-badge.boolean { background: #f3e5f5; color: #7b1fa2; }
    
    .checkbox-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .checkbox-item input[type="checkbox"] {
      width: auto;
    }
    
    .json-editor {
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }
    
    .actions-bar {
      position: sticky;
      bottom: 0;
      background: var(--surface);
      padding: 16px;
      border-top: 2px solid var(--muted);
      margin-top: 20px;
      border-radius: 0 0 12px 12px;
    }
    
    .changed-field {
      background: #fff3e0 !important;
    }
    
    .readonly-field {
      background: #f5f5f5 !important;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="flex-between">
    <h1>ğŸ—„ï¸ æ•°æ®åº“ç¼–è¾‘ç®¡ç†</h1>
    <div class="flex">
      <input type="password" id="adminToken" placeholder="ç®¡ç†å‘˜ Token" style="width:220px;">
      <button class="btn" id="toggleToken">æ˜¾ç¤º</button>
      <button class="btn" id="saveToken">ä¿å­˜</button>
    </div>
  </div>

  <div class="card" id="guardCard">
    <div class="flex-between">
      <div>
        <div style="font-weight:600; margin-bottom:6px;">éœ€è¦ç®¡ç†å‘˜ Token</div>
        <div style="color: #876;">ç¼–è¾‘æ•°æ®åº“æ•°æ®éœ€è¦ç®¡ç†å‘˜æƒé™</div>
      </div>
      <button class="btn primary" id="enterAdmin">è¿›å…¥ç®¡ç†</button>
    </div>
  </div>

  <div id="adminPanel" class="hidden">
    <!-- æœç´¢åŒºåŸŸ -->
    <div class="card">
      <h2>æœç´¢è§’è‰²å¡</h2>
      <div class="search-bar">
        <input type="text" id="searchInput" placeholder="è¾“å…¥å¡åæˆ–ä½œè€…åï¼ˆæ”¯æŒæ¨¡ç³ŠåŒ¹é…ï¼‰...">
        <select id="categoryFilter">
          <option value="">å…¨éƒ¨åˆ†åŒº</option>
          <option value="éè¾¹é™">éè¾¹é™</option>
          <option value="è¾¹é™">è¾¹é™</option>
          <option value="æ·±æ¸Š">æ·±æ¸Š</option>
        </select>
        <button class="btn primary" id="searchBtn">æœç´¢</button>
        <button class="btn" id="clearBtn">æ¸…ç©º</button>
      </div>
      
      <div id="cardListContainer" class="hidden">
        <div class="card-list" id="cardList"></div>
      </div>
    </div>

    <!-- ç¼–è¾‘åŒºåŸŸ -->
    <div class="card hidden" id="editCard">
      <div class="flex-between">
        <h2>ç¼–è¾‘è§’è‰²å¡æ•°æ®</h2>
        <div class="flex">
          <button class="btn" id="resetBtn">é‡ç½®</button>
          <button class="btn primary" id="saveBtn">ä¿å­˜æ›´æ”¹</button>
        </div>
      </div>
      
      <div id="statusMessage"></div>
      
      <div class="form-grid" id="formContainer"></div>
      
      <div class="actions-bar">
        <div class="flex-between">
          <div>
            <span id="changedCount" style="color: #876; font-size: 13px;"></span>
          </div>
          <div class="flex">
            <button class="btn" id="cancelBtn">å–æ¶ˆ</button>
            <button class="btn primary" id="saveBtnBottom">ä¿å­˜æ›´æ”¹</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let adminToken = '';
    let currentCard = null;
    let originalCard = null;
    let changedFields = new Set();

    // Token ç®¡ç†
    const tokenInput = document.getElementById('adminToken');
    const toggleTokenBtn = document.getElementById('toggleToken');
    const saveTokenBtn = document.getElementById('saveToken');
    const enterAdminBtn = document.getElementById('enterAdmin');
    const guardCard = document.getElementById('guardCard');
    const adminPanel = document.getElementById('adminPanel');

    // ä» localStorage åŠ è½½ token
    const savedToken = localStorage.getItem('adminToken');
    if (savedToken) {
      adminToken = savedToken;
      tokenInput.value = savedToken;
      enterAdmin();
    }

    toggleTokenBtn.addEventListener('click', () => {
      if (tokenInput.type === 'password') {
        tokenInput.type = 'text';
        toggleTokenBtn.textContent = 'éšè—';
      } else {
        tokenInput.type = 'password';
        toggleTokenBtn.textContent = 'æ˜¾ç¤º';
      }
    });

    saveTokenBtn.addEventListener('click', () => {
      adminToken = tokenInput.value.trim();
      if (adminToken) {
        localStorage.setItem('adminToken', adminToken);
        alert('Token å·²ä¿å­˜');
        enterAdmin();
      }
    });

    enterAdminBtn.addEventListener('click', () => {
      adminToken = tokenInput.value.trim();
      if (!adminToken) {
        alert('è¯·è¾“å…¥ç®¡ç†å‘˜ Token');
        return;
      }
      enterAdmin();
    });

    function enterAdmin() {
      guardCard.classList.add('hidden');
      adminPanel.classList.remove('hidden');
    }

    // æœç´¢åŠŸèƒ½
    const searchInput = document.getElementById('searchInput');
    const categoryFilter = document.getElementById('categoryFilter');
    const searchBtn = document.getElementById('searchBtn');
    const clearBtn = document.getElementById('clearBtn');
    const cardListContainer = document.getElementById('cardListContainer');
    const cardList = document.getElementById('cardList');

    searchBtn.addEventListener('click', searchCards);
    clearBtn.addEventListener('click', () => {
      searchInput.value = '';
      categoryFilter.value = '';
      cardListContainer.classList.add('hidden');
      document.getElementById('editCard').classList.add('hidden');
    });

    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') searchCards();
    });

    async function searchCards() {
      const query = searchInput.value.trim();
      const category = categoryFilter.value;
      
      if (!query && !category) {
        alert('è¯·è¾“å…¥æœç´¢å…³é”®è¯æˆ–é€‰æ‹©åˆ†åŒº');
        return;
      }

      cardList.innerHTML = '<div style="padding: 20px; text-align: center;"><span class="loading"></span> æœç´¢ä¸­...</div>';
      cardListContainer.classList.remove('hidden');

      try {
        const params = new URLSearchParams();
        if (query) params.append('search', query);
        if (category) params.append('category', category);
        params.append('action', 'list');
        params.append('pageSize', '50');

        const response = await fetch(`/api/cards?${params}`, {
          headers: {
            'Authorization': `Bearer ${adminToken}`
          }
        });

        const result = await response.json();
        
        if (!result.success) {
          throw new Error(result.message || 'æœç´¢å¤±è´¥');
        }

        const cards = result.cards || [];
        
        if (cards.length === 0) {
          cardList.innerHTML = '<div style="padding: 20px; text-align: center; color: #876;">æœªæ‰¾åˆ°åŒ¹é…çš„è§’è‰²å¡</div>';
          return;
        }

        cardList.innerHTML = cards.map(card => `
          <div class="card-item" data-card-id="${card.id}">
            <div class="card-item-title">${escapeHtml(card.cardName || 'æœªå‘½å')}</div>
            <div class="card-item-meta">
              ID: ${card.id} | åˆ†åŒº: ${card.category || 'æœªçŸ¥'} | ä½œè€…: ${escapeHtml(card.authorName || 'åŒ¿å')}
            </div>
          </div>
        `).join('');

        // æ·»åŠ ç‚¹å‡»äº‹ä»¶
        cardList.querySelectorAll('.card-item').forEach(item => {
          item.addEventListener('click', () => {
            const cardId = item.dataset.cardId;
            loadCardForEdit(cardId);
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            cardList.querySelectorAll('.card-item').forEach(i => i.classList.remove('selected'));
            item.classList.add('selected');
          });
        });

      } catch (error) {
        cardList.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--danger);">é”™è¯¯: ${error.message}</div>`;
      }
    }

    // åŠ è½½å¡ç‰‡æ•°æ®ç”¨äºç¼–è¾‘
    async function loadCardForEdit(cardId) {
      const editCard = document.getElementById('editCard');
      const formContainer = document.getElementById('formContainer');
      
      editCard.classList.remove('hidden');
      formContainer.innerHTML = '<div style="padding: 20px; text-align: center;"><span class="loading"></span> åŠ è½½ä¸­...</div>';

      try {
        const response = await fetch(`/api/card-detail?id=${cardId}`, {
          headers: {
            'Authorization': `Bearer ${adminToken}`
          }
        });

        const result = await response.json();
        
        if (!result.success || !result.card) {
          throw new Error(result.message || 'åŠ è½½å¤±è´¥');
        }

        currentCard = result.card;
        // ç¡®ä¿idå­—æ®µå­˜åœ¨ï¼ˆAPIè¿”å›çš„æ˜¯cardIdï¼‰
        if (!currentCard.id && currentCard.cardId) {
          currentCard.id = currentCard.cardId;
        }
        originalCard = JSON.parse(JSON.stringify(currentCard)); // æ·±æ‹·è´
        changedFields.clear();
        
        renderEditForm();
        updateChangedCount();

      } catch (error) {
        formContainer.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--danger);">é”™è¯¯: ${error.message}</div>`;
      }
    }

    // æ¸²æŸ“ç¼–è¾‘è¡¨å•
    function renderEditForm() {
      const formContainer = document.getElementById('formContainer');
      const card = currentCard;

      // å®šä¹‰å­—æ®µé…ç½®
      const fieldConfig = {
        // åŸºæœ¬ä¿¡æ¯
        id: { label: 'å¡ç‰‡ID', type: 'text', readonly: true },
        cardName: { label: 'å¡å', type: 'text', required: true },
        cardType: { label: 'å¡ç‰‡ç±»å‹', type: 'text' },
        category: { label: 'åˆ†åŒº', type: 'select', options: ['éè¾¹é™', 'è¾¹é™', 'æ·±æ¸Š'] },
        
        // ä½œè€…ä¿¡æ¯
        authorName: { label: 'ä½œè€…å', type: 'text' },
        authorId: { label: 'ä½œè€…ID', type: 'text' },
        isAnonymous: { label: 'æ˜¯å¦åŒ¿å', type: 'boolean' },
        submitterUserId: { label: 'æäº¤è€…ç”¨æˆ·ID', type: 'text' },
        submitterUsername: { label: 'æäº¤è€…ç”¨æˆ·å', type: 'text' },
        submitterDisplayName: { label: 'æäº¤è€…æ˜¾ç¤ºå', type: 'text' },
        
        // è§’è‰²ä¿¡æ¯
        characters: { label: 'è§’è‰²', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        orientation: { label: 'æ€§å‘', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        background: { label: 'èƒŒæ™¯', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        tags: { label: 'æ ‡ç­¾', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        primaryTags: { label: 'ä¸»è¦æ ‡ç­¾', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        warnings: { label: 'è­¦å‘Š', type: 'text' },
        secondaryWarning: { label: 'äºŒæ¬¡æ’é›·', type: 'textarea' },
        description: { label: 'æè¿°', type: 'textarea' },
        userLimit: { label: 'ç”¨æˆ·é™åˆ¶', type: 'text' },
        
        // ä¸‹è½½è¦æ±‚ï¼ˆå¤šé€‰ä¸‹æ‹‰ï¼‰
        downloadRequirements: { label: 'ä¸‹è½½è¦æ±‚', type: 'multiselect', options: [
          { value: '', label: 'ï¼ˆæ— ï¼‰', isClearOption: true },
          { value: 'ç‚¹èµ', label: 'ç‚¹èµ' },
          { value: 'è¯„è®º', label: 'è¯„è®º' },
          { value: 'ç‚¹èµä¸è¯„è®º', label: 'ç‚¹èµä¸è¯„è®º' },
          { value: 'ç‚¹èµæˆ–è¯„è®º', label: 'ç‚¹èµæˆ–è¯„è®º' }
        ], help: 'å¯å¤šé€‰ï¼Œä¹Ÿå¯ä¸é€‰ã€‚é€‰æ‹©"ï¼ˆæ— ï¼‰"å¯æ¸…ç©ºæ‰€æœ‰é€‰æ‹©' },
        
        // æ–‡ä»¶ä¿¡æ¯
        cardFileKey: { label: 'å¡ç‰‡æ–‡ä»¶Key', type: 'text' },
        cardJsonFileKey: { label: 'JSONæ–‡ä»¶Key', type: 'text' },
        avatarImageKey: { label: 'å¤´åƒKey', type: 'text' },
        galleryImageKeys: { label: 'ç”»å»Šå›¾ç‰‡Keys', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        
        // é™„ä»¶ä¿¡æ¯
        attachmentKeys: { label: 'é™„ä»¶Keys', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        attachmentOriginalNames: { label: 'é™„ä»¶åŸå§‹åç§°', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        attachmentDescriptions: { label: 'é™„ä»¶æè¿°', type: 'json', help: 'JSONæ•°ç»„æ ¼å¼' },
        attachmentSummary: { label: 'é™„ä»¶æ€»è¯´æ˜', type: 'textarea' },
        
        // å…¶å¥¹ä¿¡æ¯
        threadTitle: { label: 'å¸–å­æ ‡é¢˜', type: 'text' },
        threadId: { label: 'å¸–å­ID', type: 'text' },
        firstMessageId: { label: 'é¦–æ¥¼æ¶ˆæ¯ID', type: 'text' },
        otherInfo: { label: 'å…¶å¥¹ä¿¡æ¯', type: 'textarea' },
        nameRelation: { label: 'åç§°å…³ç³»', type: 'text' },
        
        // ç»Ÿè®¡ä¿¡æ¯
        likes: { label: 'ç‚¹èµæ•°', type: 'number' },
        
        // æ—¶é—´ä¿¡æ¯
        createdAt: { label: 'åˆ›å»ºæ—¶é—´', type: 'text', readonly: true },
        updatedAt: { label: 'æ›´æ–°æ—¶é—´', type: 'text', readonly: true }
      };

      const html = Object.entries(fieldConfig).map(([key, config]) => {
        // è·³è¿‡éšè—å­—æ®µ
        if (config.hidden) {
          return '';
        }
        
        const value = card[key];
        const displayValue = formatFieldValue(value, config.type);
        const fieldId = `field_${key}`;
        const isReadonly = config.readonly || false;
        const isChanged = changedFields.has(key);
        
        let inputHtml = '';
        
        if (config.type === 'textarea') {
          inputHtml = `<textarea id="${fieldId}" ${isReadonly ? 'readonly' : ''} class="${isChanged ? 'changed-field' : ''} ${isReadonly ? 'readonly-field' : ''}">${escapeHtml(displayValue)}</textarea>`;
        } else if (config.type === 'select') {
          const options = config.options.map(opt => 
            `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`
          ).join('');
          inputHtml = `<select id="${fieldId}" ${isReadonly ? 'disabled' : ''} class="${isChanged ? 'changed-field' : ''} ${isReadonly ? 'readonly-field' : ''}">${options}</select>`;
        } else if (config.type === 'boolean') {
          const checked = value === true || value === 1 || value === '1';
          inputHtml = `<div class="checkbox-item">
            <input type="checkbox" id="${fieldId}" ${checked ? 'checked' : ''} ${isReadonly ? 'disabled' : ''} class="${isReadonly ? 'readonly-field' : ''}">
            <label for="${fieldId}">${checked ? 'æ˜¯' : 'å¦'}</label>
          </div>`;
        } else if (config.type === 'json') {
          inputHtml = `<textarea id="${fieldId}" ${isReadonly ? 'readonly' : ''} class="json-editor ${isChanged ? 'changed-field' : ''} ${isReadonly ? 'readonly-field' : ''}" style="min-height: 120px;">${escapeHtml(displayValue)}</textarea>`;
        } else if (config.type === 'multiselect') {
          // å¤„ç†å¤šé€‰ä¸‹æ‹‰æ¡†
          const currentValues = Array.isArray(value) ? value : (typeof value === 'string' && value ? (() => {
            try {
              return JSON.parse(value);
            } catch (e) {
              return [];
            }
          })() : []);
          const options = config.options.map(opt => {
            const optValue = typeof opt === 'string' ? opt : opt.value;
            const optLabel = typeof opt === 'string' ? opt : opt.label;
            const isClearOption = typeof opt === 'object' && opt.isClearOption;
            // ç©ºé€‰é¡¹åªåœ¨æ²¡æœ‰å…¶ä»–é€‰æ‹©æ—¶æ˜¾ç¤ºä¸ºé€‰ä¸­
            const isSelected = isClearOption ? (currentValues.length === 0 || currentValues.includes('')) : currentValues.includes(optValue);
            return `<option value="${escapeHtml(optValue)}" ${isSelected ? 'selected' : ''}>${escapeHtml(optLabel)}</option>`;
          }).join('');
          inputHtml = `<select id="${fieldId}" multiple ${isReadonly ? 'disabled' : ''} class="${isChanged ? 'changed-field' : ''} ${isReadonly ? 'readonly-field' : ''}" style="min-height: 100px;">${options}</select>`;
          
          // æ·»åŠ æ¸…ç©ºé€‰é¡¹çš„ç‚¹å‡»å¤„ç†
          if (!isReadonly) {
            setTimeout(() => {
              const selectEl = document.getElementById(fieldId);
              if (selectEl) {
                selectEl.addEventListener('change', function() {
                  const selectedValues = Array.from(this.selectedOptions).map(opt => opt.value);
                  // å¦‚æœé€‰æ‹©äº†"ï¼ˆæ— ï¼‰"é€‰é¡¹ï¼Œæ¸…ç©ºå…¶ä»–æ‰€æœ‰é€‰æ‹©
                  if (selectedValues.includes('')) {
                    Array.from(this.options).forEach(opt => {
                      if (opt.value !== '') {
                        opt.selected = false;
                      }
                    });
                  } else {
                    // å¦‚æœé€‰æ‹©äº†å…¶ä»–é€‰é¡¹ï¼Œå–æ¶ˆ"ï¼ˆæ— ï¼‰"é€‰é¡¹
                    const clearOption = Array.from(this.options).find(opt => opt.value === '');
                    if (clearOption) {
                      clearOption.selected = false;
                    }
                  }
                  // è§¦å‘å­—æ®µå˜æ›´æ£€æµ‹
                  const fieldName = this.id.replace('field_', '');
                  checkFieldChanged(fieldName);
                });
              }
            }, 100);
          }
        } else {
          inputHtml = `<input type="${config.type}" id="${fieldId}" value="${escapeHtml(displayValue)}" ${isReadonly ? 'readonly' : ''} class="${isChanged ? 'changed-field' : ''} ${isReadonly ? 'readonly-field' : ''}">`;
        }

        const typeBadge = config.type === 'json' ? '<span class="field-type-badge json">JSON</span>' :
                         config.type === 'boolean' ? '<span class="field-type-badge boolean">å¸ƒå°”</span>' :
                         config.type === 'number' ? '<span class="field-type-badge integer">æ•°å­—</span>' :
                         config.type === 'multiselect' ? '<span class="field-type-badge json">å¤šé€‰</span>' : '';

        return `
          <div class="form-group ${config.fullWidth ? 'full-width' : ''}">
            <label class="form-label" for="${fieldId}">
              ${config.label}${typeBadge}
            </label>
            ${inputHtml}
            ${config.help ? `<div class="form-help">${config.help}</div>` : ''}
          </div>
        `;
      }).join('');

      formContainer.innerHTML = html;

      // æ·»åŠ è¾“å…¥ç›‘å¬
      formContainer.querySelectorAll('input, textarea, select').forEach(input => {
        if (!input.readOnly && !input.disabled) {
          input.addEventListener('input', () => {
            const fieldName = input.id.replace('field_', '');
            checkFieldChanged(fieldName);
          });
          input.addEventListener('change', () => {
            const fieldName = input.id.replace('field_', '');
            checkFieldChanged(fieldName);
          });
        }
      });
    }

    // æ ¼å¼åŒ–å­—æ®µå€¼ç”¨äºæ˜¾ç¤º
    function formatFieldValue(value, type) {
      if (value === null || value === undefined) return '';
      
      if (type === 'json') {
        if (typeof value === 'string') {
          try {
            const parsed = JSON.parse(value);
            return JSON.stringify(parsed, null, 2);
          } catch (e) {
            return value;
          }
        } else if (Array.isArray(value) || typeof value === 'object') {
          return JSON.stringify(value, null, 2);
        }
        return String(value);
      }
      
      if (type === 'multiselect') {
        // å¤šé€‰ä¸‹æ‹‰æ¡†ä¸éœ€è¦æ ¼å¼åŒ–ï¼Œç›´æ¥è¿”å›åŸå€¼
        return value;
      }
      
      if (type === 'boolean') {
        return value === true || value === 1 || value === '1';
      }
      
      return String(value);
    }

    // æ£€æŸ¥å­—æ®µæ˜¯å¦æ”¹å˜
    function checkFieldChanged(fieldName) {
      const input = document.getElementById(`field_${fieldName}`);
      if (!input) return;

      const config = getFieldConfig(fieldName);
      if (!config) return;

      let currentValue = getInputValue(input, config.type);
      let originalValue = originalCard[fieldName];

        // å¤„ç† JSON å­—æ®µ
        if (config.type === 'json') {
          try {
            currentValue = currentValue ? JSON.parse(currentValue) : null;
          } catch (e) {
            // æ— æ•ˆçš„ JSONï¼Œæ ‡è®°ä¸ºå·²æ”¹å˜
            changedFields.add(fieldName);
            updateChangedCount();
            input.classList.add('changed-field');
            return;
          }
          
          if (typeof originalValue === 'string') {
            try {
              originalValue = JSON.parse(originalValue);
            } catch (e) {
              originalValue = originalValue;
            }
          }
        }
        
        // å¤„ç†å¤šé€‰ä¸‹æ‹‰æ¡†
        if (config.type === 'multiselect') {
          // currentValue å·²ç»æ˜¯æ•°ç»„ï¼ˆä» getInputValue è¿”å›ï¼‰
          // éœ€è¦å¤„ç† originalValue
          if (typeof originalValue === 'string') {
            try {
              originalValue = JSON.parse(originalValue);
            } catch (e) {
              originalValue = [];
            }
          }
          if (!Array.isArray(originalValue)) {
            originalValue = [];
          }
          // æ’åºåæ¯”è¾ƒï¼Œé¿å…é¡ºåºä¸åŒå¯¼è‡´çš„è¯¯åˆ¤
          currentValue = [...currentValue].sort();
          originalValue = [...originalValue].sort();
        }

      // å¤„ç†å¸ƒå°”å­—æ®µ
      if (config.type === 'boolean') {
        currentValue = input.checked;
        originalValue = originalValue === true || originalValue === 1 || originalValue === '1';
      }

      // æ¯”è¾ƒå€¼
      const isChanged = JSON.stringify(currentValue) !== JSON.stringify(originalValue);
      
      if (isChanged) {
        changedFields.add(fieldName);
        input.classList.add('changed-field');
      } else {
        changedFields.delete(fieldName);
        input.classList.remove('changed-field');
      }
      
      updateChangedCount();
    }

    // è·å–è¾“å…¥å€¼
    function getInputValue(input, type) {
      if (type === 'boolean') {
        return input.checked;
      }
      if (type === 'multiselect') {
        // è·å–å¤šé€‰ä¸‹æ‹‰æ¡†çš„æ‰€æœ‰é€‰ä¸­å€¼ï¼Œè¿‡æ»¤æ‰ç©ºå€¼
        const values = Array.from(input.selectedOptions).map(option => option.value).filter(v => v !== '');
        return values;
      }
      return input.value;
    }

    // è·å–å­—æ®µé…ç½®
    function getFieldConfig(fieldName) {
      const fieldConfigs = {
        id: { type: 'text' },
        cardName: { type: 'text' },
        cardType: { type: 'text' },
        category: { type: 'select' },
        authorName: { type: 'text' },
        authorId: { type: 'text' },
        isAnonymous: { type: 'boolean' },
        submitterUserId: { type: 'text' },
        submitterUsername: { type: 'text' },
        submitterDisplayName: { type: 'text' },
        characters: { type: 'json' },
        orientation: { type: 'json' },
        background: { type: 'json' },
        tags: { type: 'json' },
        primaryTags: { type: 'json' },
        downloadRequirements: { type: 'multiselect' },
        warnings: { type: 'text' },
        secondaryWarning: { type: 'textarea' },
        description: { type: 'textarea' },
        userLimit: { type: 'text' },
        cardFileKey: { type: 'text' },
        cardJsonFileKey: { type: 'text' },
        avatarImageKey: { type: 'text' },
        galleryImageKeys: { type: 'json' },
        attachmentKeys: { type: 'json' },
        attachmentOriginalNames: { type: 'json' },
        attachmentDescriptions: { type: 'json' },
        attachmentSummary: { type: 'textarea' },
        threadTitle: { type: 'text' },
        threadId: { type: 'text' },
        firstMessageId: { type: 'text' },
        otherInfo: { type: 'textarea' },
        nameRelation: { type: 'text' },
        likes: { type: 'number' },
        createdAt: { type: 'text' },
        updatedAt: { type: 'text' }
      };
      return fieldConfigs[fieldName] || { type: 'text' };
    }

    // æ›´æ–°æ”¹å˜è®¡æ•°
    function updateChangedCount() {
      const count = changedFields.size;
      const countEl = document.getElementById('changedCount');
      if (count > 0) {
        countEl.textContent = `å·²ä¿®æ”¹ ${count} ä¸ªå­—æ®µ`;
        countEl.style.color = 'var(--warning)';
      } else {
        countEl.textContent = 'æœªä¿®æ”¹';
        countEl.style.color = '#876';
      }
    }

    // ä¿å­˜æ›´æ”¹
    const saveBtn = document.getElementById('saveBtn');
    const saveBtnBottom = document.getElementById('saveBtnBottom');
    const resetBtn = document.getElementById('resetBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const statusMessage = document.getElementById('statusMessage');

    saveBtn.addEventListener('click', saveChanges);
    saveBtnBottom.addEventListener('click', saveChanges);
    resetBtn.addEventListener('click', resetForm);
    cancelBtn.addEventListener('click', () => {
      if (confirm('ç¡®å®šè¦å–æ¶ˆå—ï¼Ÿæœªä¿å­˜çš„æ›´æ”¹å°†ä¸¢å¤±ã€‚')) {
        document.getElementById('editCard').classList.add('hidden');
        changedFields.clear();
      }
    });

    async function saveChanges() {
      if (changedFields.size === 0) {
        showStatus('æ²¡æœ‰éœ€è¦ä¿å­˜çš„æ›´æ”¹', 'info');
        return;
      }

      if (!confirm(`ç¡®å®šè¦ä¿å­˜ ${changedFields.size} ä¸ªå­—æ®µçš„æ›´æ”¹å—ï¼Ÿ`)) {
        return;
      }

      const updateData = {};
      
      changedFields.forEach(fieldName => {
        const input = document.getElementById(`field_${fieldName}`);
        if (!input) return;

        const config = getFieldConfig(fieldName);
        let value = getInputValue(input, config.type);
        
      // å¤„ç† JSON å­—æ®µ
      if (config.type === 'json') {
        try {
          value = value ? JSON.parse(value) : [];
        } catch (e) {
          showStatus(`å­—æ®µ ${fieldName} çš„ JSON æ ¼å¼æ— æ•ˆ: ${e.message}`, 'error');
          throw new Error(`JSON æ ¼å¼é”™è¯¯: ${fieldName}`);
        }
      }
      
      // å¤„ç†å¤šé€‰ä¸‹æ‹‰æ¡†ï¼ˆä¿å­˜ä¸º JSON æ•°ç»„ï¼‰
      if (config.type === 'multiselect') {
        // value å·²ç»æ˜¯æ•°ç»„ï¼Œç›´æ¥ä½¿ç”¨
        if (!Array.isArray(value)) {
          value = [];
        }
      }
        
        // å¤„ç†å¸ƒå°”å­—æ®µ
        if (config.type === 'boolean') {
          value = input.checked;
        }
        
        // å¤„ç†æ•°å­—å­—æ®µ
        if (config.type === 'number') {
          value = parseInt(value) || 0;
        }
        
        // ç©ºå­—ç¬¦ä¸²è½¬ä¸º nullï¼ˆé™¤äº† JSON æ•°ç»„ï¼Œç©ºæ•°ç»„åº”è¯¥ä¿æŒä¸ºç©ºæ•°ç»„ï¼‰
        if (value === '' && config.type !== 'json') {
          value = null;
        }
        
        updateData[fieldName] = value;
      });

      try {
        showStatus('ä¿å­˜ä¸­...', 'info');
        
        // ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„IDå­—æ®µ
        const cardId = currentCard.id || currentCard.cardId;
        if (!cardId) {
          throw new Error('æ— æ³•è·å–å¡ç‰‡ID');
        }
        
        const response = await fetch(`/api/card-detail?id=${cardId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${adminToken}`
          },
          body: JSON.stringify(updateData)
        });

        const result = await response.json();
        
        if (!result.success) {
          throw new Error(result.message || 'ä¿å­˜å¤±è´¥');
        }

        showStatus(`âœ… æˆåŠŸä¿å­˜ ${result.updatedFields || changedFields.size} ä¸ªå­—æ®µçš„æ›´æ”¹`, 'success');
        
        // é‡æ–°åŠ è½½æ•°æ®
        setTimeout(() => {
          const cardId = currentCard.id || currentCard.cardId;
          if (cardId) {
            loadCardForEdit(cardId);
          }
        }, 1000);

      } catch (error) {
        showStatus(`âŒ ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
      }
    }

    function resetForm() {
      if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ›´æ”¹å—ï¼Ÿ')) {
        changedFields.clear();
        const cardId = currentCard.id || currentCard.cardId;
        if (cardId) {
          loadCardForEdit(cardId);
        }
      }
    }

    function showStatus(message, type) {
      statusMessage.innerHTML = `<div class="status ${type}">${message}</div>`;
      setTimeout(() => {
        statusMessage.innerHTML = '';
      }, 5000);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>

