<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>标签管理后台</title>
  <style>
    :root {
      --bg: #F3E9DD;
      --surface: #FAF4EC;
      --text: #5C4033;
      --muted: #D9CBBE;
      --accent: #8B5E3C;
      --accent-2: #6D4C3D;
      --pill-bg: #EADFD2;
    }

    html, body { background: var(--bg); color: var(--text); font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB, Microsoft YaHei, Helvetica Neue, Arial, Noto Sans, "Noto Sans CJK SC", sans-serif; }
    body { margin: 24px; max-width: 980px; margin-left: auto; margin-right: auto; }
    h1 { font-size: 24px; margin: 0 0 16px; }
    .card { background: var(--surface); border: 1px solid var(--muted); border-radius: 12px; padding: 16px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: 10px; border: 1px solid var(--muted); background: var(--surface); cursor: pointer; }
    .btn.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    .btn.danger { background: #B5534E; color: #fff; border-color: #B5534E; }
    .btn.small { padding: 6px 10px; border-radius: 8px; }
    .muted { color: #9A8274; font-size: 13px; }
    input[type="text"], textarea { padding: 8px 10px; border: 1px solid var(--muted); border-radius: 8px; background: #fff; color: var(--text); }
    input[type="text"] { height: 34px; }
    .input-sm { height: 30px; padding: 6px 8px; }
    .space { height: 16px; }
    .grid { display: grid; gap: 12px; }
    .category { border: 1px dashed var(--muted); border-radius: 10px; padding: 12px; background: #fff; }
    .category-head { display: flex; align-items: center; gap: 10px; justify-content: space-between; }
    .tags-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    .tags-table th, .tags-table td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
    .tags-table th { font-weight: 600; color: #7b6558; background: #f9f6f2; }
    .right { text-align: right; }
    .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .token-box { display: flex; align-items: center; gap: 8px; }
    .status { margin-top: 10px; font-weight: 600; color: var(--accent-2); }
    .hidden { display: none; }
    .drag-handle { cursor: grab; user-select: none; color: #9A8274; display: inline-flex; align-items: center; justify-content: center; width: 24px; }
    .drag-handle::before { content: "≡"; font-size: 18px; line-height: 1; }
    .dragging { opacity: 0.6; }
    .drag-over { outline: 2px dashed var(--accent); outline-offset: 2px; }
    .col-handle { width: 36px; }
    .big-check { width: 18px; height: 18px; accent-color: var(--accent); }
    .tags-table th, .tags-table td { vertical-align: middle; }
    .tags-table.fixed { width: 100%; table-layout: fixed; }
    .tags-table.fixed th.col-handle, .tags-table.fixed td.col-handle { width: 36px; }
    .tags-table.fixed th.col-name, .tags-table.fixed td.col-name { width: 80%; }
    .tags-table.fixed th.col-op, .tags-table.fixed td.col-op { width: 20%; text-align: center; }
    .add-tag-btn { width: 32px; height: 32px; border-radius: 50%; border: none; cursor: pointer; color: #fff; background: var(--accent); display: inline-flex; align-items: center; justify-content: center; font-size: 18px; line-height: 1; margin-top: 8px; }
    .add-tag-btn:hover { background: var(--accent-2); }
    .collapse-toggle { 
      display: inline-flex; 
      align-items: center; 
      justify-content: center; 
      width: 20px; 
      height: 20px; 
      border: none; 
      background: transparent; 
      color: #9A8274; 
      cursor: pointer; 
      font-size: 14px; 
      line-height: 1; 
      transition: color 0.15s ease, transform 0.15s ease;
      padding: 0;
      margin-right: 4px;
    }
    .collapse-toggle:hover { color: var(--accent); }
    .collapse-toggle.collapsed { transform: rotate(-90deg); }
    
    /* 预览区域样式 */
    #tagsPreview { 
      padding: 16px; 
      background: #fff; 
      border-radius: 8px; 
      min-height: 400px;
      overflow-y: visible; 
    }
    #tagsPreview.collapsed { 
      max-height: 200px; 
      overflow-y: auto;
    }
    .preview-category { 
      margin-bottom: 20px; 
      padding: 12px; 
      background: var(--surface); 
      border: 1px solid var(--muted); 
      border-radius: 8px;
      position: relative;
    }
    .preview-category-header { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      margin-bottom: 10px; 
      font-weight: 600;
      color: var(--text);
    }
    .preview-category-header .category-name { flex: 1; }
    .preview-category-header .quick-add { 
      opacity: 0; 
      transition: opacity 0.2s; 
    }
    .preview-category:hover .quick-add { opacity: 1; }
    .preview-pill-group { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 10px; 
    }
    .preview-pill {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 36px;
      padding: 0 14px;
      border-radius: 999px;
      border: 1px solid var(--muted);
      background: var(--pill-bg);
      color: var(--text);
      cursor: move;
      transition: all 0.15s ease;
      user-select: none;
    }
    .preview-pill:hover { border-color: var(--accent); box-shadow: 0 2px 6px rgba(139,94,60,0.15); }
    .preview-pill.dragging { opacity: 0.5; }
    .preview-pill.drag-over-pill { outline: 2px solid var(--accent); outline-offset: 2px; }
    .preview-pill-lg { 
      height: 42px; 
      padding: 0 18px; 
      font-size: 16px; 
      font-weight: 600; 
      background: #DFCDBB;
    }
    .preview-category.drag-over-cat { 
      outline: 2px dashed var(--accent); 
      outline-offset: 4px; 
    }
    .quick-add-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: none;
      background: var(--accent);
      color: #fff;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      line-height: 1;
      padding: 0;
    }
    .quick-add-btn:hover { background: var(--accent-2); }
  </style>
</head>
<body>
  <div class="header">
    <h1>标签管理后台</h1>
    <div class="token-box">
      <input type="password" id="adminToken" placeholder="管理员 Token" class="input-sm" style="width:220px;">
      <button class="btn small" id="toggleToken">显示</button>
      <button class="btn primary small" id="saveToken">保存Token</button>
      <button class="btn small" id="clearToken">清除</button>
    </div>
  </div>

  <div class="card" id="guardCard">
    <div class="row">
      <div>
        <div style="font-weight:600; margin-bottom:6px;">需要管理员 Token</div>
        <div class="muted">将通过 Authorization: Bearer 头发送，保存在本地浏览器，不会上传。</div>
      </div>
      <div style="flex:1"></div>
      <button class="btn primary" id="enterAdmin">进入管理</button>
    </div>
  </div>

  <div class="space"></div>

  <div id="editor" class="hidden">
    <div class="card">
      <div class="row" style="justify-content: space-between; margin-bottom: 12px;">
        <div>
          <div style="font-weight:700;">Tags 预览</div>
          <div class="muted">实时查看标签效果，拖拽排序，右键删除，Hover 大类可快速添加标签。</div>
        </div>
        <div class="row">
          <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #876;">
            <span>分区:</span>
            <select id="previewPartition" style="padding: 4px 8px; border: 1px solid var(--muted); border-radius: 6px; background: #fff;">
              <option value="">公共</option>
              <option value="feibianxian">非边限</option>
              <option value="bianxian">边限</option>
              <option value="shenyuan">深渊</option>
            </select>
          </label>
          <button class="btn small" id="addPreviewCategory">+ 新增大类</button>
          <button class="btn primary small" id="savePreview">保存预览更改</button>
          <button class="btn small" id="togglePreviewSize">展开/收起</button>
        </div>
      </div>
      <div id="tagsPreview" style="border: 1px solid var(--muted);">
        <!-- 动态渲染 tags 预览 -->
      </div>
    </div>

    <div class="space"></div>
    <div class="space"></div>

    <div class="card">
      <div class="row" style="justify-content: space-between;">
        <div>
          <div style="font-weight:700;">板块管理</div>
          <div class="muted">拖拽左侧把手可调整板块顺序；每个板块内可增删条目。</div>
        </div>
        <div class="row">
          <button class="btn" id="reloadConfig">重新加载</button>
          <button class="btn primary" id="saveConfig">保存更改</button>
        </div>
      </div>
      <div class="space"></div>
      <div id="sectionsHost" class="grid"></div>
      <div class="space"></div>
      <div class="row" style="justify-content: space-between; align-items: center;">
        <button class="btn" id="addSection">+ 新增板块</button>
        <div class="row">
          <button class="btn" id="reloadConfig2">重新加载</button>
          <button class="btn primary" id="saveConfig2">保存更改</button>
        </div>
      </div>
      <div id="status" class="status"></div>
    </div>
  </div>

  <script>
    const state = {
      config: null
    };

    function getToken() {
      return localStorage.getItem('admin_token') || (document.getElementById('adminToken').value || '').trim();
    }

    function setStatus(text, isError) {
      const el = document.getElementById('status');
      el.textContent = text || '';
      el.style.color = isError ? '#B5534E' : 'var(--accent-2)';
    }

    function h(tag, attrs = {}, children = []) {
      const el = document.createElement(tag);
      Object.entries(attrs).forEach(([k, v]) => {
        if (k === 'class') el.className = v;
        else if (k === 'text') el.textContent = v;
        else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.slice(2), v);
        else if (k === 'checked' || k === 'disabled' || k === 'selected') el[k] = v; // DOM 属性而非 attribute
        else el.setAttribute(k, v);
      });
      children.forEach(c => el.appendChild(typeof c === 'string' ? document.createTextNode(c) : c));
      return el;
    }

    async function loadConfig() {
      setStatus('');
      const res = await fetch('/api/config');
      const data = await res.json();
      if (!data.success) throw new Error(data.message || '加载失败');
      state.config = data.config || {};
      normalizeSections();
      renderSections();
    }

  function normalizeSections() {
    // 生成统一的 sections 顺序，默认 partition 在第一个
    if (!Array.isArray(state.config.sections)) {
      state.config.sections = ['partition'];
    }
    if (!state.config.sections.includes('partition')) {
      state.config.sections.unshift('partition');
    }
  }

    function renderSections() {
      const host = document.getElementById('sectionsHost');
      host.innerHTML = '';
      const order = state.config.sections || [];
      order.forEach((key, idx) => {
        if (key === 'partition') host.appendChild(renderPartitionSection(idx));
        else if (key.startsWith('custom:')) {
          const title = key.slice(7);
          host.appendChild(renderCustomSectionByTitle(title, idx));
        }
      });
      // 同步更新预览
      renderTagsPreview();
    }

    function renderPartitionSection(sectionIndex) {
      const wrap = h('div', { class: 'category', draggable: 'true' });
      const body = h('div', { id: 'partitions' });
      const toggleBtn = h('button', { class: 'collapse-toggle', title: '收起/展开' }, ['▼']);
      toggleBtn.onclick = () => { 
        const hidden = body.classList.toggle('hidden'); 
        toggleBtn.classList.toggle('collapsed', hidden);
      };
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [
          toggleBtn,
          h('span', { class: 'drag-handle', title: '拖动排序', onmousedown: () => { dragState.allowed = true; } }),
          h('div', { text: '分区专属 Tags', style: 'font-weight:600;' })
        ]),
        h('div', {}, [ h('span', { class: 'muted', text: '包含 公共/非边限/边限/深渊' }) ])
      ]);
      // 先挂载，再渲染内部内容，避免找不到节点
      wrap.appendChild(head);
      wrap.appendChild(body);
      renderPartitions(body);
      // 拖拽排序支持
      wrap.addEventListener('dragstart', (e) => { if (!dragState.allowed) { e.preventDefault(); return; } dragState.mode='section'; dragState.srcIndex = sectionIndex; wrap.classList.add('dragging'); setTimeout(()=>{dragState.allowed=false;},0); });
      wrap.addEventListener('dragend', ()=> wrap.classList.remove('dragging'));
      wrap.addEventListener('dragover', (e)=>{ if (dragState.mode==='section') { e.preventDefault(); wrap.classList.add('drag-over'); }});
      wrap.addEventListener('dragleave', ()=> wrap.classList.remove('drag-over'));
      wrap.addEventListener('drop', (e)=>{ e.preventDefault(); wrap.classList.remove('drag-over'); if (dragState.mode!=='section') return; const from=dragState.srcIndex; const to=sectionIndex; if (from===to) return; const arr=state.config.sections; const [m]=arr.splice(from,1); arr.splice(to,0,m); renderSections(); });
      return wrap;
    }

    function createSimpleSection(key, title, sectionIndex, isSection) {
      if (!Array.isArray(state.config[key])) state.config[key] = [];
      const wrap = h('div', { class: 'category', draggable: isSection ? 'true' : 'false' });
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [
          isSection ? h('span', { class: 'drag-handle', title: '拖动排序', onmousedown: () => { dragState.allowed = true; } }) : document.createTextNode(''),
          h('div', { text: title, style: 'font-weight:600;' })
        ]),
        h('div', {}, [ h('button', { class: 'btn small', onclick: () => addSimple(key) }, ['+ 添加']) ])
      ]);

      const table = h('table', { class: 'tags-table fixed' });
      const thead = h('thead', {}, [
        h('tr', {}, [
          h('th', { class: 'col-handle', text: ' ' }),
          h('th', { class: 'col-name', text: '名称' }),
          h('th', { class: 'col-op', text: '操作' })
        ])
      ]);
      const tbody = h('tbody');
      state.config[key].forEach((item, idx) => {
        const tr = h('tr', { class: 'simple-row', draggable: 'true', 'data-key': key }, [
          h('td', { class: 'col-handle' }, [ h('span', { class: 'drag-handle', title: '拖动排序', onmousedown: () => { dragState.allowed = true; dragState.simpleKey = key; } }) ]),
          h('td', { class: 'col-name' }, [ h('input', { type: 'text', value: item.label || '', placeholder: '名称', style: 'width:80%;', oninput: (e) => { item.label = e.target.value; item.value = e.target.value; } }) ]),
          h('td', { class: 'col-op' }, [ h('button', { class: 'btn danger small', onclick: () => removeSimple(key, idx) }, ['删除']) ])
        ]);
        tbody.appendChild(tr);
      });
      table.appendChild(thead);
      table.appendChild(tbody);

      wrap.appendChild(head);
      wrap.appendChild(table);

      if (isSection) {
        wrap.addEventListener('dragstart', (e) => { if (!dragState.allowed) { e.preventDefault(); return; } dragState.mode='section'; dragState.srcIndex = sectionIndex; wrap.classList.add('dragging'); setTimeout(()=>{dragState.allowed=false;},0); });
        wrap.addEventListener('dragend', ()=> wrap.classList.remove('dragging'));
        wrap.addEventListener('dragover', (e)=>{ if (dragState.mode==='section') { e.preventDefault(); wrap.classList.add('drag-over'); }});
        wrap.addEventListener('dragleave', ()=> wrap.classList.remove('drag-over'));
        wrap.addEventListener('drop', (e)=>{ e.preventDefault(); wrap.classList.remove('drag-over'); if (dragState.mode!=='section') return; const from=dragState.srcIndex; const to=sectionIndex; if (from===to) return; const arr=state.config.sections; const [m]=arr.splice(from,1); arr.splice(to,0,m); renderSections(); });
      }
      return wrap;
    }

  function renderCustomSectionByTitle(title, sectionIndex) {
    if (!Array.isArray(state.config.customSections)) state.config.customSections = [];
    let sec = state.config.customSections.find(s => s && s.title === title);
    if (!sec) { sec = { title, multiple: true, items: [] }; state.config.customSections.push(sec); }
    const wrap = h('div', { class: 'category', draggable: 'true' });
    const toggleBtn = h('button', { class: 'collapse-toggle', title: '收起/展开' }, ['▼']);
    const head = h('div', { class: 'category-head' }, [
      h('div', { class: 'row' }, [
        toggleBtn,
        h('span', { class: 'drag-handle', title: '拖动排序', onmousedown: () => { dragState.allowed = true; } }),
        h('input', { type: 'text', value: sec.title || '', placeholder: '板块名称', style: 'width:240px;', oninput: (e) => { const old = sec.title; sec.title = e.target.value; const idx = state.config.sections.indexOf('custom:'+old); if (idx>=0) state.config.sections[idx] = 'custom:'+sec.title; } })
      ]),
      h('div', {}, [ 
        h('button', { class: 'btn danger small', onclick: () => { const idx = state.config.sections.indexOf('custom:'+sec.title); if (idx>=0) state.config.sections.splice(idx,1); const si = state.config.customSections.indexOf(sec); if (si>=0) state.config.customSections.splice(si,1); renderSections(); } }, ['删除板块']) 
      ])
    ]);
    
    const settingRow = h('div', { class: 'row', style: 'margin-top:8px; align-items:center; gap:10px; flex-wrap:wrap;' }, [
      h('label', {}, [
        h('input', { class: 'big-check', type: 'checkbox', checked: sec.multiple !== false, onchange: (e) => { sec.multiple = e.target.checked; } }),
        document.createTextNode(' 可多选')
      ]),
      h('span', { text: '显示条件（可选）：', style: 'margin-left:16px; color:#876; font-size:13px;' }),
      h('input', { type: 'text', value: sec.showIf || '', placeholder: '如 性向:GB', style: 'width:180px;', oninput: (e) => { sec.showIf = e.target.value.trim() || undefined; } })
    ]);

    const table = h('table', { class: 'tags-table' });
    const thead = h('thead', {}, [ 
      h('tr', {}, [ 
        h('th', { class: 'col-handle', text: ' ' }), 
        h('th', { text: '名称' }), 
        h('th', { text: '启用条件 (|或 !非)', style: 'width:200px;' }), 
        h('th', { text: '互斥项', style: 'width:140px;' }), 
        h('th', { class: 'right', text: '操作', style: 'width:80px;' }) 
      ]) 
    ]);
    const tbody = h('tbody');
    (sec.items || []).forEach((item, idx) => {
      const tr = h('tr', { class: 'simple-row', draggable: 'true', 'data-key': 'section-'+sec.title }, [
        h('td', { class: 'col-handle' }, [ h('span', { class: 'drag-handle', title: '拖动排序', onmousedown: () => { dragState.allowed = true; dragState.simpleKey = 'section-'+sec.title; } }) ]),
        h('td', {}, [ h('input', { type: 'text', value: item.label || '', placeholder: '名称', style: 'width:100%;', oninput: (e) => { item.label = e.target.value; item.value = e.target.value; } }) ]),
        h('td', {}, [ h('input', { type: 'text', value: item.enableIf || '', placeholder: '!性向:无CP|性向:GB', style: 'width:100%;', oninput: (e) => { item.enableIf = e.target.value.trim() || undefined; } }) ]),
        h('td', {}, [ h('input', { type: 'text', value: (item.mutexWith || []).join(','), placeholder: '如 原创,同人', style: 'width:100%;', oninput: (e) => { const v = e.target.value.trim(); item.mutexWith = v ? v.split(',').map(x => x.trim()).filter(Boolean) : undefined; } }) ]),
        h('td', { class: 'right' }, [ h('button', { class: 'btn danger small', onclick: () => { sec.items.splice(idx,1); renderSections(); } }, ['删除']) ])
      ]);
      tbody.appendChild(tr);
    });
    table.appendChild(thead); table.appendChild(tbody);
    
    const footer = h('div', { style: 'text-align:right; margin-top:8px;' }, [
      h('button', { class: 'add-tag-btn', onclick: () => { (sec.items || (sec.items=[])).push({ label: '', value: '' }); renderSections(); } }, ['+'])
    ]);
    
    const contentWrap = h('div');
    contentWrap.appendChild(settingRow);
    contentWrap.appendChild(table);
    contentWrap.appendChild(footer);
    toggleBtn.onclick = () => { 
      const hidden = contentWrap.classList.toggle('hidden'); 
      toggleBtn.classList.toggle('collapsed', hidden);
    };
    wrap.appendChild(head);
    wrap.appendChild(contentWrap);
    // section 拖拽支持
    wrap.addEventListener('dragstart', (e) => { if (!dragState.allowed) { e.preventDefault(); return; } dragState.mode='section'; dragState.srcIndex = sectionIndex; wrap.classList.add('dragging'); setTimeout(()=>{dragState.allowed=false;},0); });
    wrap.addEventListener('dragend', ()=> wrap.classList.remove('dragging'));
    wrap.addEventListener('dragover', (e)=>{ if (dragState.mode==='section') { e.preventDefault(); wrap.classList.add('drag-over'); }});
    wrap.addEventListener('dragleave', ()=> wrap.classList.remove('drag-over'));
    wrap.addEventListener('drop', (e)=>{ e.preventDefault(); wrap.classList.remove('drag-over'); if (dragState.mode!=='section') return; const from=dragState.srcIndex; const to=sectionIndex; if (from===to) return; const arr=state.config.sections; const [m]=arr.splice(from,1); arr.splice(to,0,m); renderSections(); });
    return wrap;
  }

    function addSimple(key) {
      if (!Array.isArray(state.config[key])) state.config[key] = [];
      state.config[key].push({ label: '', value: '' });
      renderSections();
    }

    function removeSimple(key, idx) {
      state.config[key].splice(idx, 1);
      renderSections();
    }

  function renderPartitions(targetHost) {
    const host = targetHost || document.getElementById('partitions');
    if (!host) return;
    host.innerHTML = '';
    const keys = [
      { k: 'common', name: '公共' },
      { k: 'feibianxian', name: '非边限' },
      { k: 'bianxian', name: '边限' },
      { k: 'shenyuan', name: '深渊' }
    ];
    if (!state.config.tagPartitions) state.config.tagPartitions = {};
    
    // 每次渲染时从 localStorage 读取最新状态
    if (!window.partitionCollapseStates) {
      window.partitionCollapseStates = {};
    }
    keys.forEach(({ k }) => {
      const saved = localStorage.getItem(`partition_${k}_collapsed`);
      window.partitionCollapseStates[k] = saved === 'true';
    });
    
    keys.forEach(({ k, name }) => {
      const section = h('div', { class: 'category', style: 'margin-top:12px;' });
      const toggleBtn = h('button', { class: 'collapse-toggle', title: '收起/展开' }, ['▼']);
      const list = h('div', { class: 'grid' });
      
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [ 
          toggleBtn,
          h('div', { text: name, style: 'font-weight:600;' }) 
        ]),
        h('div', {}, [ h('button', { class: 'btn small', onclick: () => addPartitionCategory(k) }, ['+ 添加分类']) ])
      ]);
      
      const arr = Array.isArray(state.config.tagPartitions[k]) ? state.config.tagPartitions[k] : (state.config.tagPartitions[k] = []);
      arr.forEach((cat, idx) => list.appendChild(renderCategory(cat, idx, { scope: 'partition', key: k })));
      
      // 应用折叠状态
      const isCollapsed = window.partitionCollapseStates[k];
      if (isCollapsed) {
        list.classList.add('hidden');
        toggleBtn.classList.add('collapsed');
      }
      
      // 绑定折叠按钮
      toggleBtn.onclick = () => {
        const hidden = list.classList.toggle('hidden');
        toggleBtn.classList.toggle('collapsed', hidden);
        window.partitionCollapseStates[k] = hidden;
        localStorage.setItem(`partition_${k}_collapsed`, String(hidden));
      };
      
      section.appendChild(head);
      section.appendChild(list);
      host.appendChild(section);
    });
  }

    function addPartitionCategory(key) {
      if (!state.config.tagPartitions) state.config.tagPartitions = {};
      const arr = Array.isArray(state.config.tagPartitions[key]) ? state.config.tagPartitions[key] : (state.config.tagPartitions[key] = []);
      arr.push({ category: '新分类', asPill: false, tags: [] });
      renderPartitions();
    }

  function renderCategory(cat, index, ctx) {
      const scope = (ctx && ctx.scope === 'partition') ? 'partition' : 'normal';
      const box = h('div', { class: 'category', draggable: 'true', 'data-scope': scope, 'data-index': String(index), 'data-partition-key': (scope === 'partition' ? (ctx && ctx.key || '') : '') });
      const toggleBtn = h('button', { class: 'collapse-toggle', title: '收起/展开' }, ['▼']);
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [
          toggleBtn,
          h('span', { class: 'drag-handle', title: '拖动排序', 'data-role': 'cat-handle', onmousedown: () => { dragState.allowed = true; } }),
          h('input', { type: 'text', value: cat.category || '', placeholder: '分类名称', style: 'width:240px;', oninput: (e) => { cat.category = e.target.value; } })
        ]),
        h('div', {}, [
          h('button', { class: 'btn small', onclick: () => { 
            if (!Array.isArray(cat.tags)) cat.tags = []; 
            cat.tags.push({ label: '', value: '' }); 
            (ctx && ctx.scope === 'partition') ? renderPartitions() : renderCategories(); 
          } }, ['+ 添加标签']),
          h('span', { text: ' ' }),
          h('button', { class: 'btn danger small', onclick: () => { if (ctx && ctx.scope === 'partition') { const arr = (state.config.tagPartitions && state.config.tagPartitions[ctx.key]) || []; arr.splice(index, 1); renderPartitions(); } else { state.config.tagCategories.splice(index, 1); renderCategories(); } } }, ['删除分类'])
        ])
      ]);

      const table = h('table', { class: 'tags-table' });
      const thead = h('thead', {}, [
        h('tr', {}, [
          h('th', { class: 'col-handle', text: ' ' }),
          h('th', { text: '显示名' }),
          h('th', { text: '启用条件 (|或 !非)', style: 'width:180px;' }),
          h('th', { text: '互斥项', style: 'width:120px;' }),
          h('th', { class: 'right', text: '操作', style: 'width:70px;' })
        ])
      ]);
      const tbody = h('tbody');
      (Array.isArray(cat.tags) ? cat.tags : []).forEach((tag, tIdx) => {
        const tr = h('tr', { class: 'tag-row', draggable: 'true' }, [
          h('td', { class: 'col-handle' }, [ h('span', { class: 'drag-handle', title: '拖动排序', onmousedown: () => { dragState.allowed = true; dragState.tagCatIndex = index; } }) ]),
          h('td', {}, [h('input', { type: 'text', value: tag.label || '', placeholder: '如 校园', style: 'width:100%;', oninput: (e) => { tag.label = e.target.value; tag.value = e.target.value; } })]),
          h('td', {}, [h('input', { type: 'text', value: tag.showIf || '', placeholder: '!性向:无CP|性向:GB', style: 'width:100%;', oninput: (e) => { tag.showIf = e.target.value.trim() || undefined; } })]),
          h('td', {}, [h('input', { type: 'text', value: (tag.mutexWith || []).join(','), placeholder: '如 都市,古代', style: 'width:100%;', oninput: (e) => { const v = e.target.value.trim(); tag.mutexWith = v ? v.split(',').map(x => x.trim()).filter(Boolean) : undefined; } })]),
          h('td', { class: 'right' }, [h('button', { class: 'btn danger small', onclick: () => { cat.tags.splice(tIdx, 1); (ctx && ctx.scope === 'partition') ? renderPartitions() : renderCategories(); } }, ['删除'])])
        ]);
        tbody.appendChild(tr);
      });
      table.appendChild(thead);
      table.appendChild(tbody);

      // 分类设置：是否作为整类可单独点选（胶囊）+ 分类级别的条件和互斥
      const pillRow = h('div', { class: 'row', style: 'margin-top:8px; align-items:center; gap:10px; flex-wrap:wrap;' }, [
        h('label', {}, [
          h('input', { class: 'big-check', type: 'checkbox', checked: !!cat.asPill, onchange: (e) => { 
            cat.asPill = e.target.checked; 
          } }),
          document.createTextNode(' 整类可点选（胶囊）')
        ]),
        h('span', { text: '显示条件：', style: 'margin-left:16px; color:#876; font-size:13px;' }),
        h('input', { type: 'text', value: cat.showIf || '', placeholder: '如 性向:GB', style: 'width:140px;', oninput: (e) => { cat.showIf = e.target.value.trim() || undefined; } }),
        h('span', { text: '互斥：', style: 'margin-left:8px; color:#876; font-size:13px;' }),
        h('input', { type: 'text', value: (cat.mutexWith || []).join(','), placeholder: '如 场景,关系', style: 'width:120px;', oninput: (e) => { const v = e.target.value.trim(); cat.mutexWith = v ? v.split(',').map(x => x.trim()).filter(Boolean) : undefined; } })
      ]);

      const tableFooter = h('div', { style: 'text-align: right; margin-top: 8px;' }, [
        h('button', { class: 'add-tag-btn', type: 'button', title: '添加标签', onclick: () => {
          if (!Array.isArray(cat.tags)) cat.tags = [];
          cat.tags.push({ label: '', value: '' });
          (ctx && ctx.scope === 'partition') ? renderPartitions() : renderCategories();
        } }, ['+'])
      ]);

      const contentWrap = h('div');
      contentWrap.appendChild(pillRow);
      contentWrap.appendChild(table);
      contentWrap.appendChild(tableFooter);
      toggleBtn.onclick = () => { 
        const hidden = contentWrap.classList.toggle('hidden'); 
        toggleBtn.classList.toggle('collapsed', hidden);
      };
      box.appendChild(head);
      box.appendChild(contentWrap);

      // --- 拖拽（分类） ---
      box.addEventListener('dragstart', (e) => {
        if (!dragState.allowed) { e.preventDefault(); return; }
        dragState.mode = 'category';
        dragState.srcCat = index;
        e.dataTransfer && (e.dataTransfer.effectAllowed = 'move');
        box.classList.add('dragging');
        // 还原 handle 授权标记
        setTimeout(() => { dragState.allowed = false; }, 0);
      });
      box.addEventListener('dragend', () => {
        box.classList.remove('dragging');
        document.querySelectorAll('.category.drag-over').forEach(el => el.classList.remove('drag-over'));
      });
      box.addEventListener('dragover', (e) => {
        if (dragState.mode === 'category') { e.preventDefault(); box.classList.add('drag-over'); }
      });
      box.addEventListener('dragleave', () => { box.classList.remove('drag-over'); });
      box.addEventListener('drop', (e) => {
        e.preventDefault();
        box.classList.remove('drag-over');
        if (dragState.mode !== 'category') return;
        const from = dragState.srcCat;
        const to = index;
        if (from === undefined || to === undefined || from === to) return;
        const arr = (ctx && ctx.scope === 'partition') ? ((state.config.tagPartitions && state.config.tagPartitions[ctx.key]) || []) : (state.config.tagCategories || []);
        const [m] = arr.splice(from, 1);
        arr.splice(to, 0, m);
        setStatus('已调整分类顺序（未保存）');
        (ctx && ctx.scope === 'partition') ? renderPartitions() : renderCategories();
      });
      return box;
    }

    function addCategory() {
      if (!Array.isArray(state.config.tagCategories)) state.config.tagCategories = [];
      state.config.tagCategories.push({ category: '新分类', asPill: false, tags: [] });
      renderCategories();
    }
  

    // --- 拖拽（标签行） ---
    document.addEventListener('dragstart', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (!tr) return;
      if (!dragState.allowed) { e.preventDefault(); return; }
      const tbody = tr.parentElement;
      const catBox = tr.closest('.category');
      const catIndex = catBox ? parseInt(catBox.getAttribute('data-index') || '-1', 10) : -1;
      const rows = Array.from(tbody.querySelectorAll('tr.tag-row'));
      const rowIndex = rows.indexOf(tr);
      dragState.mode = 'tag';
      dragState.srcCat = catIndex;
      dragState.srcTag = rowIndex;
      dragState.scope = catBox ? catBox.getAttribute('data-scope') : 'normal';
      dragState.partitionKey = catBox ? catBox.getAttribute('data-partition-key') : '';
      e.dataTransfer && (e.dataTransfer.effectAllowed = 'move');
      tr.classList.add('dragging');
      setTimeout(() => { dragState.allowed = false; }, 0);
    });
    document.addEventListener('dragend', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (tr) tr.classList.remove('dragging');
      document.querySelectorAll('tr.tag-row.drag-over').forEach(el => el.classList.remove('drag-over'));
    });
    document.addEventListener('dragover', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (!tr) return;
      if (dragState.mode === 'tag') { e.preventDefault(); tr.classList.add('drag-over'); }
    });
    document.addEventListener('dragleave', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (tr) tr.classList.remove('drag-over');
    });
    document.addEventListener('drop', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.tag-row');
      if (!tr) return;
      e.preventDefault();
      tr.classList.remove('drag-over');
      if (dragState.mode !== 'tag') return;
      // 仅限同分类内排序
      const targetCatBox = tr.closest('.category');
      const targetCatIndex = targetCatBox ? parseInt(targetCatBox.getAttribute('data-index') || '-1', 10) : -1;
      if (targetCatIndex !== dragState.srcCat) return;
      const rows = Array.from(tr.parentElement.querySelectorAll('tr.tag-row'));
      const to = rows.indexOf(tr);
      const from = dragState.srcTag;
      if (from === undefined || to === undefined || from === to) return;
      let cat;
      if (dragState.scope === 'partition') {
        const arr = (state.config.tagPartitions && state.config.tagPartitions[dragState.partitionKey]) || [];
        cat = arr[targetCatIndex];
      } else {
        cat = (state.config.tagCategories || [])[targetCatIndex];
      }
      if (!cat || !Array.isArray(cat.tags)) return;
      const [m] = cat.tags.splice(from, 1);
      cat.tags.splice(to, 0, m);
      setStatus('已调整标签顺序（未保存）');
      (dragState.scope === 'partition') ? renderPartitions() : renderCategories();
    });

    // 全局兜底清理拖拽样式，避免残留半透明蒙版
    // 注意：不要在这里重置 dragState.mode，因为 drop 事件需要用到它
    document.addEventListener('dragend', () => {
      document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
      document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
      // 延迟重置，确保 drop 事件先执行
      setTimeout(() => {
        dragState.mode = null; 
        dragState.allowed = false;
      }, 100);
    });

    // --- 触摸端（移动设备）对标签行的排序降级支持 ---
    let touchScrollBlock = false;
    document.addEventListener('touchstart', (e) => {
      const handle = e.target && e.target.closest && e.target.closest('tr.tag-row .drag-handle');
      if (!handle) return;
      const tr = handle.closest('tr.tag-row');
      if (!tr) return;
      const catBox = tr.closest('.category');
      dragState.mode = 'touch-tag';
      dragState.touchActive = true;
      dragState.srcRow = tr;
      dragState.scope = catBox ? catBox.getAttribute('data-scope') : 'normal';
      dragState.partitionKey = catBox ? catBox.getAttribute('data-partition-key') : '';
      dragState.srcCat = catBox ? parseInt(catBox.getAttribute('data-index') || '-1', 10) : -1;
      const rows = Array.from(tr.parentElement.querySelectorAll('tr.tag-row'));
      dragState.srcTag = rows.indexOf(tr);
      tr.classList.add('dragging');
      touchScrollBlock = true;
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (!dragState.touchActive) return;
      const t = e.touches[0];
      const el = document.elementFromPoint(t.clientX, t.clientY);
      const over = el && el.closest && el.closest('tr.tag-row');
      document.querySelectorAll('tr.tag-row.drag-over').forEach(x => x.classList.remove('drag-over'));
      if (over && over.parentElement === dragState.srcRow.parentElement) {
        over.classList.add('drag-over');
        dragState.touchOverRow = over;
      }
      if (touchScrollBlock) e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', () => {
      if (!dragState.touchActive) return;
      const srcRow = dragState.srcRow;
      const overRow = dragState.touchOverRow;
      const rows = Array.from(srcRow.parentElement.querySelectorAll('tr.tag-row'));
      const from = dragState.srcTag;
      const to = overRow ? rows.indexOf(overRow) : from;
      srcRow.classList.remove('dragging');
      if (overRow) overRow.classList.remove('drag-over');
      dragState.touchActive = false;
      touchScrollBlock = false;
      if (from === undefined || to === undefined || from === to) return;
      let cat;
      if (dragState.scope === 'partition') {
        const arr = (state.config.tagPartitions && state.config.tagPartitions[dragState.partitionKey]) || [];
        cat = arr[dragState.srcCat];
      } else {
        cat = (state.config.tagCategories || [])[dragState.srcCat];
      }
      if (!cat || !Array.isArray(cat.tags)) return;
      const [m] = cat.tags.splice(from, 1);
      cat.tags.splice(to, 0, m);
      setStatus('已调整标签顺序（未保存）');
      (dragState.scope === 'partition') ? renderPartitions() : renderCategories();
    });

    // --- 拖拽（简单数组：性向/背景/限制 + 自定义板块条目） ---
    document.addEventListener('dragstart', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (!tr) return;
      if (!dragState.allowed) { 
        e.preventDefault(); 
        return; 
      }
      const key = tr.getAttribute('data-key');
      const rows = Array.from(tr.parentElement.querySelectorAll('tr.simple-row'));
      dragState.mode = 'simple';
      dragState.simpleKey = key;
      dragState.srcIndex = rows.indexOf(tr);
      e.dataTransfer && (e.dataTransfer.effectAllowed = 'move');
      tr.classList.add('dragging');
      setTimeout(() => { dragState.allowed = false; }, 0);
    });
    document.addEventListener('dragend', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (tr) tr.classList.remove('dragging');
      document.querySelectorAll('tr.simple-row.drag-over').forEach(el => el.classList.remove('drag-over'));
    });
    document.addEventListener('dragover', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (!tr) return;
      if (dragState.mode === 'simple') { e.preventDefault(); tr.classList.add('drag-over'); }
    });
    document.addEventListener('dragleave', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (tr) tr.classList.remove('drag-over');
    });
    document.addEventListener('drop', (e) => {
      const tr = e.target && e.target.closest && e.target.closest('tr.simple-row');
      if (!tr) return;
      e.preventDefault();
      tr.classList.remove('drag-over');
      if (dragState.mode !== 'simple') {
        return;
      }
      const key = tr.getAttribute('data-key');
      if (key !== dragState.simpleKey) {
        return;
      }
      const rows = Array.from(tr.parentElement.querySelectorAll('tr.simple-row'));
      const to = rows.indexOf(tr);
      const from = dragState.srcIndex;
      if (from === undefined || to === undefined || from === to) return;
      
      // 判断是自定义板块还是普通配置数组
      if (key.startsWith('section-')) {
        // 自定义板块的条目
        const sectionTitle = key.slice(8); // 去掉 'section-' 前缀
        if (!Array.isArray(state.config.customSections)) {
          return;
        }
        const sec = state.config.customSections.find(s => s && s.title === sectionTitle);
        if (!sec) {
          return;
        }
        if (!Array.isArray(sec.items)) {
          return;
        }
        const [m] = sec.items.splice(from, 1);
        sec.items.splice(to, 0, m);
        setStatus('已调整顺序（未保存）');
        renderSections();
      } else {
        // 普通配置数组（如性向、背景等）
        const arr = state.config[key];
        if (!Array.isArray(arr)) return;
        const [m] = arr.splice(from, 1);
        arr.splice(to, 0, m);
        setStatus('已调整顺序（未保存）');
        renderSections();
      }
    });

  function renderCustomSections() {
    const host = document.getElementById('customSections');
    host.innerHTML = '';
    if (!Array.isArray(state.config.customSections)) state.config.customSections = [];
    state.config.customSections.forEach((sec, sIdx) => {
      const box = h('div', { class: 'category', style: 'margin-top:12px;' });
      const head = h('div', { class: 'category-head' }, [
        h('div', { class: 'row' }, [
          h('span', { class: 'drag-handle', title: '拖动排序', onmousedown: () => { dragState.allowed = true; } }),
          h('input', { type: 'text', value: sec.title || '', placeholder: '板块名称，如：题材', style: 'width:240px;', oninput: (e) => { sec.title = e.target.value; } })
        ]),
        h('div', {}, [
          h('button', { class: 'btn danger small', onclick: () => { state.config.customSections.splice(sIdx, 1); renderCustomSections(); } }, ['删除板块'])
        ])
      ]);

      const table = h('table', { class: 'tags-table fixed' });
      const thead = h('thead', {}, [
        h('tr', {}, [
          h('th', { class: 'col-handle', text: ' ' }),
          h('th', { class: 'col-name', text: '名称' }),
          h('th', { class: 'col-op', text: '操作' })
        ])
      ]);
      const tbody = h('tbody');
      (Array.isArray(sec.items) ? sec.items : (sec.items = [])).forEach((item, iIdx) => {
        const tr = h('tr', { class: 'simple-row', draggable: 'true', 'data-key': `section-${sIdx}` }, [
          h('td', { class: 'col-handle' }, [ h('span', { class: 'drag-handle', title: '拖动排序', onmousedown: () => { dragState.allowed = true; dragState.simpleKey = `section-${sIdx}`; } }) ]),
          h('td', { class: 'col-name' }, [ h('input', { type: 'text', value: item.label || '', placeholder: '如 都市', style: 'width:80%;', oninput: (e) => { item.label = e.target.value; item.value = e.target.value; } }) ]),
          h('td', { class: 'col-op' }, [ h('button', { class: 'btn danger small', onclick: () => { sec.items.splice(iIdx, 1); renderCustomSections(); } }, ['删除']) ])
        ]);
        tbody.appendChild(tr);
      });
      table.appendChild(thead);
      table.appendChild(tbody);

      const footer = h('div', { style: 'text-align:right; margin-top:8px;' }, [
        h('button', { class: 'add-tag-btn', onclick: () => { (sec.items || (sec.items = [])).push({ label: '', value: '' }); renderCustomSections(); } }, ['+'])
      ]);

      box.appendChild(head);
      box.appendChild(table);
      box.appendChild(footer);
      host.appendChild(box);
    });
  }

  document.getElementById('addSection').addEventListener('click', () => {
    if (!Array.isArray(state.config.customSections)) state.config.customSections = [];
    let title = '新板块';
    let counter = 1;
    while (state.config.customSections.some(s => s.title === title)) {
      title = '新板块' + (++counter);
    }
    state.config.customSections.push({ title, multiple: true, items: [] });
    state.config.sections.push('custom:'+title);
    renderSections();
  });

     async function saveConfig() {
       setStatus('保存中...');
       const token = getToken();
       if (!token) { setStatus('请先输入并保存管理员 Token', true); return; }
       const body = {
         tagCategories: state.config.tagCategories,
         tagPartitions: state.config.tagPartitions,
         customSections: state.config.customSections,
         sections: state.config.sections
       };
       try {
         const res = await fetch('/api/config', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
           body: JSON.stringify(body)
         });
         const data = await res.json();
         if (!res.ok || !data.success) throw new Error(data.message || '保存失败');
         state.config = data.config;
         normalizeSections();
         renderSections();
         setStatus('已保存');
       } catch (e) {
         setStatus('保存失败：' + e.message, true);
       }
     }

     function renderTagsPreview() {
       const container = document.getElementById('tagsPreview');
       if (!container) return;
       
       const partition = document.getElementById('previewPartition').value;
       const categories = getPreviewCategories(partition);
       
       container.innerHTML = '';
       categories.forEach((cat, catIdx) => {
         const catDiv = h('div', { class: 'preview-category', draggable: 'true', 'data-cat-index': String(catIdx), 'data-partition': partition });
         
         const header = h('div', { class: 'preview-category-header' }, [
           h('span', { class: 'category-name', text: cat.category }),
           h('button', { class: 'quick-add-btn quick-add', title: '添加标签', onclick: () => quickAddTag(partition, catIdx) }, ['+'])
         ]);
         
         const pillGroup = h('div', { class: 'preview-pill-group' });
         
         // 大类胶囊
         if (cat.asPill) {
           const label = cat.pillLabel || cat.category;
           const pill = h('div', { class: 'preview-pill preview-pill-lg', draggable: 'false', text: label });
           pillGroup.appendChild(pill);
         }
         
         // 子标签
         (cat.tags || []).forEach((tag, tagIdx) => {
           const pill = h('div', { 
             class: 'preview-pill', 
             draggable: 'true', 
             text: tag.label,
             'data-tag-index': String(tagIdx),
             'data-cat-index': String(catIdx)
           });
           
           // 右键删除
           pill.addEventListener('contextmenu', (e) => {
             e.preventDefault();
             if (confirm(`确定删除标签"${tag.label}"？`)) {
               const arr = getPartitionArray(partition);
               const cat = arr[catIdx];
               if (cat && Array.isArray(cat.tags)) {
                 cat.tags.splice(tagIdx, 1);
                 renderTagsPreview();
                 setStatus('已删除标签（未保存）');
               }
             }
           });
           
           // 标签拖拽
           pill.addEventListener('dragstart', (e) => {
             previewDragState.mode = 'tag';
             previewDragState.srcCat = catIdx;
             previewDragState.srcTag = tagIdx;
             previewDragState.partition = partition;
             pill.classList.add('dragging');
             e.dataTransfer.effectAllowed = 'move';
           });
           pill.addEventListener('dragend', () => {
             pill.classList.remove('dragging');
             document.querySelectorAll('.preview-pill.drag-over-pill').forEach(el => el.classList.remove('drag-over-pill'));
           });
           pill.addEventListener('dragover', (e) => {
             if (previewDragState.mode === 'tag' && previewDragState.partition === partition) {
               e.preventDefault();
               pill.classList.add('drag-over-pill');
             }
           });
           pill.addEventListener('dragleave', () => pill.classList.remove('drag-over-pill'));
           pill.addEventListener('drop', (e) => {
             e.preventDefault();
             pill.classList.remove('drag-over-pill');
             if (previewDragState.mode !== 'tag' || previewDragState.partition !== partition) return;
             const toCat = catIdx;
             const toTag = tagIdx;
             if (previewDragState.srcCat === toCat && previewDragState.srcTag === toTag) return;
             
             // 同分类内排序
             if (previewDragState.srcCat === toCat) {
               const arr = getPartitionArray(partition);
               const cat = arr[toCat];
               if (!cat || !Array.isArray(cat.tags)) return;
               const [moved] = cat.tags.splice(previewDragState.srcTag, 1);
               cat.tags.splice(toTag, 0, moved);
               renderTagsPreview();
               setStatus('已调整标签顺序（未保存）');
             }
           });
           
           pillGroup.appendChild(pill);
         });
         
         catDiv.appendChild(header);
         catDiv.appendChild(pillGroup);
         
         // 分类拖拽
         catDiv.addEventListener('dragstart', (e) => {
           if (e.target.classList.contains('preview-pill')) return;
           previewDragState.mode = 'category';
           previewDragState.srcCat = catIdx;
           previewDragState.partition = partition;
           catDiv.classList.add('dragging');
           e.dataTransfer.effectAllowed = 'move';
         });
         catDiv.addEventListener('dragend', () => {
           catDiv.classList.remove('dragging');
           document.querySelectorAll('.preview-category.drag-over-cat').forEach(el => el.classList.remove('drag-over-cat'));
         });
         catDiv.addEventListener('dragover', (e) => {
           if (previewDragState.mode === 'category' && previewDragState.partition === partition) {
             e.preventDefault();
             catDiv.classList.add('drag-over-cat');
           }
         });
         catDiv.addEventListener('dragleave', () => catDiv.classList.remove('drag-over-cat'));
         catDiv.addEventListener('drop', (e) => {
           e.preventDefault();
           catDiv.classList.remove('drag-over-cat');
           if (previewDragState.mode !== 'category' || previewDragState.partition !== partition) return;
           const from = previewDragState.srcCat;
           const to = catIdx;
           if (from === to) return;
           
           const arr = getPartitionArray(partition);
           const [moved] = arr.splice(from, 1);
           arr.splice(to, 0, moved);
           renderTagsPreview();
           setStatus('已调整分类顺序（未保存）');
         });
         
         container.appendChild(catDiv);
       });
     }
     
     function getPreviewCategories(partition) {
       const partitions = (state.config.tagPartitions || {});
       const common = Array.isArray(partitions.common) ? partitions.common : [];
       const extra = partition && Array.isArray(partitions[partition]) ? partitions[partition] : [];
       return mergeCategoriesByName(common, extra);
     }
     
     function getPartitionArray(partition) {
       if (!state.config.tagPartitions) state.config.tagPartitions = {};
       const key = partition || 'common';
       if (!Array.isArray(state.config.tagPartitions[key])) state.config.tagPartitions[key] = [];
       return state.config.tagPartitions[key];
     }
     
     function mergeCategoriesByName(base, extra) {
       const byName = new Map();
       const add = (arr) => {
         (arr || []).forEach(cat => {
           if (!cat || !cat.category) return;
           if (!byName.has(cat.category)) {
             byName.set(cat.category, {
               category: cat.category,
               asPill: !!cat.asPill,
               pillLabel: cat.pillLabel,
               pillValue: cat.pillValue,
               showIf: cat.showIf,
               mutexWith: cat.mutexWith,
               tags: []
             });
           }
           const entry = byName.get(cat.category);
           if (cat.asPill) entry.asPill = true;
           if (cat.pillLabel) entry.pillLabel = cat.pillLabel;
           if (cat.pillValue) entry.pillValue = cat.pillValue;
           if (cat.showIf) entry.showIf = cat.showIf;
           if (Array.isArray(cat.mutexWith) && cat.mutexWith.length) entry.mutexWith = cat.mutexWith;
           
           const seen = new Set(entry.tags.map(t => t.value || t.label));
           (cat.tags || []).forEach(t => {
             const val = (t && (t.value || t.label));
             if (!val || seen.has(val)) return;
             entry.tags.push({
               value: t.value || t.label,
               label: t.label || t.value,
               showIf: t.showIf,
               mutexWith: Array.isArray(t.mutexWith) ? t.mutexWith : undefined
             });
             seen.add(val);
           });
         });
       };
       add(base);
       add(extra);
       return Array.from(byName.values());
     }
     
     function quickAddTag(partition, catIdx) {
       const name = prompt('输入新标签名称:');
       if (!name || !name.trim()) return;
       const arr = getPartitionArray(partition);
       const cat = arr[catIdx];
       if (!cat) return;
       if (!Array.isArray(cat.tags)) cat.tags = [];
       cat.tags.push({ label: name.trim(), value: name.trim() });
       renderTagsPreview();
       setStatus('已添加标签（未保存）');
     }
     
     const previewDragState = { mode: null, srcCat: null, srcTag: null, partition: '' };

    // 拖拽状态
    const dragState = { mode: null, srcCat: null, srcTag: null, allowed: false, tagCatIndex: null, simpleKey: null, srcIndex: null, scope: 'normal', partitionKey: '', touchActive: false, srcRow: null, touchOverRow: null };

    // UI wiring
    document.getElementById('saveConfig').addEventListener('click', saveConfig);
    document.getElementById('saveConfig2').addEventListener('click', saveConfig);
    document.getElementById('reloadConfig').addEventListener('click', () => loadConfig().then(() => setStatus('已重新加载')).catch(e => setStatus('加载失败：' + e.message, true)));
    document.getElementById('reloadConfig2').addEventListener('click', () => loadConfig().then(() => setStatus('已重新加载')).catch(e => setStatus('加载失败：' + e.message, true)));

    document.getElementById('toggleToken').addEventListener('click', () => {
      const el = document.getElementById('adminToken');
      el.type = el.type === 'password' ? 'text' : 'password';
    });
    document.getElementById('saveToken').addEventListener('click', () => {
      const v = (document.getElementById('adminToken').value || '').trim();
      if (v) localStorage.setItem('admin_token', v);
      setStatus('Token 已保存在本地');
    });
    document.getElementById('clearToken').addEventListener('click', () => {
      localStorage.removeItem('admin_token');
      document.getElementById('adminToken').value = '';
      setStatus('Token 已清除');
    });
    document.getElementById('enterAdmin').addEventListener('click', () => {
      const token = getToken();
      if (!token) { setStatus('请输入 Token', true); return; }
      localStorage.setItem('admin_token', token);
      document.getElementById('guardCard').classList.add('hidden');
      document.getElementById('editor').classList.remove('hidden');
      loadConfig().catch(e => setStatus('加载失败：' + e.message, true));
    });

    // 预览界面控制
    let previewExpanded = localStorage.getItem('preview_expanded') !== 'false';
    
    function updatePreviewSize() {
      const container = document.getElementById('tagsPreview');
      if (previewExpanded) {
        container.classList.remove('collapsed');
      } else {
        container.classList.add('collapsed');
      }
      localStorage.setItem('preview_expanded', previewExpanded);
    }
    
    document.getElementById('togglePreviewSize').addEventListener('click', () => {
      previewExpanded = !previewExpanded;
      updatePreviewSize();
    });
    
    document.getElementById('previewPartition').addEventListener('change', () => {
      renderTagsPreview();
    });
    
    document.getElementById('addPreviewCategory').addEventListener('click', () => {
      const name = prompt('输入新分类名称:');
      if (!name || !name.trim()) return;
      const partition = document.getElementById('previewPartition').value || 'common';
      const arr = getPartitionArray(partition);
      arr.push({ category: name.trim(), asPill: false, tags: [] });
      renderTagsPreview();
      setStatus('已添加分类（未保存）');
    });
    
    document.getElementById('savePreview').addEventListener('click', async () => {
      setStatus('保存预览更改中...');
      const token = getToken();
      if (!token) { setStatus('请先输入并保存管理员 Token', true); return; }
      const body = {
        tagCategories: state.config.tagCategories,
        tagPartitions: state.config.tagPartitions,
        customSections: state.config.customSections,
        sections: state.config.sections
      };
      try {
        const res = await fetch('/api/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
          body: JSON.stringify(body)
        });
        const data = await res.json();
        if (!res.ok || !data.success) throw new Error(data.message || '保存失败');
        state.config = data.config;
        normalizeSections();
        renderSections();
        setStatus('预览更改已保存');
      } catch (e) {
        setStatus('保存失败：' + e.message, true);
      }
    });

    // Init
    (function init() {
      const saved = localStorage.getItem('admin_token');
      if (saved) {
        document.getElementById('adminToken').value = saved;
        document.getElementById('guardCard').classList.add('hidden');
        document.getElementById('editor').classList.remove('hidden');
        loadConfig().then(() => {
          renderTagsPreview();
          updatePreviewSize();
        }).catch(e => setStatus('加载失败：' + e.message, true));
      }
    })();
  </script>
</body>
</html>


